'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/action-queue', ['exports', 'orbit/main', 'orbit/action', 'orbit/evented', 'orbit/lib/assert'], function (exports, Orbit, Action, Evented, assert) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  var ActionQueue = (function () {
    function ActionQueue(target) {
      var _this = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _classCallCheck(this, ActionQueue);

      assert.assert('ActionQueue requires Orbit.Promise to be defined', Orbit['default'].Promise);

      this.target = target;

      this.name = options.name;
      this.bucket = options.bucket;
      this.autoProcess = options.autoProcess !== undefined ? options.autoProcess : true;
      this._reify().then(function () {
        if (_this.length > 0 && _this.autoProcess) {
          _this.process();
        }
      });
    }

    _createClass(ActionQueue, [{
      key: 'push',
      value: function push(method, options) {
        var _this2 = this;

        return this.reified.then(function () {
          var action = new Action['default'](_this2.target, method, options);
          _this2._actions.push(action);
          return _this2._persist().then(function () {
            if (_this2.autoProcess) {
              return _this2.process().then(function () {
                return action;
              });
            } else {
              return action;
            }
          });
        });
      }
    }, {
      key: 'retry',
      value: function retry() {
        var _this3 = this;

        return this.reified.then(function () {
          _this3._cancel();
          _this3.current.reset();
          return _this3._persist();
        }).then(function () {
          return _this3.process();
        });
      }
    }, {
      key: 'skip',
      value: function skip() {
        var _this4 = this;

        return this.reified.then(function () {
          _this4._cancel();
          _this4._actions.shift();
          return _this4._persist();
        }).then(function () {
          return _this4.process();
        });
      }
    }, {
      key: 'clear',
      value: function clear() {
        var _this5 = this;

        return this.reified.then(function () {
          _this5._cancel();
          _this5._actions = [];
          return _this5._persist();
        }).then(function () {
          return _this5.process();
        });
      }
    }, {
      key: 'shift',
      value: function shift() {
        var _this6 = this;

        var action = undefined;

        return this.reified.then(function () {
          _this6._cancel();
          action = _this6._actions.shift();
          return _this6._persist();
        }).then(function () {
          return action;
        });
      }
    }, {
      key: 'unshift',
      value: function unshift(method, options) {
        var _this7 = this;

        var action = undefined;

        return this.reified.then(function () {
          action = new Action['default'](_this7.target, method, options);
          _this7._cancel();
          _this7._actions.unshift(action);
          return _this7._persist();
        }).then(function () {
          return action;
        });
      }
    }, {
      key: 'process',
      value: function process() {
        var _this8 = this;

        return this.reified.then(function () {
          var resolution = _this8._resolution;

          if (!resolution) {
            if (_this8._actions.length === 0) {
              resolution = Orbit['default'].Promise.resolve();
              _this8._complete();
            } else {
              _this8._error = null;
              _this8._resolution = resolution = new Orbit['default'].Promise(function (resolve) {
                _this8._resolve = resolve;
              });
              _this8._settleEach(resolution);
            }
          }

          return resolution;
        });
      }
    }, {
      key: '_complete',
      value: function _complete() {
        if (this._resolve) {
          this._resolve();
        }
        this._error = null;
        this._resolution = null;
        this.emit('complete');
      }
    }, {
      key: '_fail',
      value: function _fail(action, e) {
        if (this._resolve) {
          this._resolve();
        }
        this._error = e;
        this._resolution = null;
        this.emit('fail', action, e);
      }
    }, {
      key: '_cancel',
      value: function _cancel() {
        this._error = null;
        this._resolution = null;
      }
    }, {
      key: '_settleEach',
      value: function _settleEach(resolution) {
        var _this9 = this;

        if (this._actions.length === 0) {
          this._complete();
        } else {
          (function () {
            var action = _this9._actions[0];

            _this9.emit('beforeAction', action);

            action.process().then(function () {
              if (resolution === _this9._resolution) {
                _this9._actions.shift();
                _this9._persist().then(function () {
                  _this9.emit('action', action);
                  _this9._settleEach(resolution);
                });
              }
            })['catch'](function (e) {
              if (resolution === _this9._resolution) {
                _this9._fail(action, e);
              }
            });
          })();
        }
      }
    }, {
      key: '_reify',
      value: function _reify() {
        var _this10 = this;

        this._actions = [];

        if (this.bucket) {
          this.reified = this.bucket.getItem(this.name).then(function (serialized) {
            return _this10._deserializeActions(serialized);
          });
        } else {
          this.reified = Orbit['default'].Promise.resolve();
        }

        return this.reified;
      }
    }, {
      key: '_deserializeActions',
      value: function _deserializeActions(serialized) {
        var _this11 = this;

        if (serialized) {
          this._actions = serialized.map(function (a) {
            return Action['default'].deserialize(_this11.target, a);
          });
        } else {
          this._actions = [];
        }
      }
    }, {
      key: '_serializeActions',
      value: function _serializeActions() {
        return this._actions.map(function (a) {
          return a.serialize();
        });
      }
    }, {
      key: '_persist',
      value: function _persist() {
        if (this.bucket) {
          return this.bucket.setItem(this.name, this._serializeActions());
        } else {
          return Orbit['default'].Promise.resolve();
        }
      }
    }, {
      key: 'length',
      get: function get() {
        return this._actions.length;
      }
    }, {
      key: 'current',
      get: function get() {
        return this._actions[0];
      }
    }, {
      key: 'error',
      get: function get() {
        return this._error;
      }
    }, {
      key: 'complete',
      get: function get() {
        return this.length === 0;
      }
    }, {
      key: 'processing',
      get: function get() {
        var current = this.current;

        return current !== undefined && current.started && !current.settled;
      }
    }]);

    return ActionQueue;
  })();

  exports['default'] = ActionQueue;

  Evented['default'].extend(ActionQueue.prototype);
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/action', ['exports', 'orbit/main'], function (exports, Orbit) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  var Action = (function () {
    /**
     * Constructor for `Action` class.
     *
     * @param  {Object} target         Target object
     * @param  {String} method         Name of method to call on `target`
     * @param  {Object} [options={}]   Options
     * @param  {Any}    [options.meta] Optional metadata
     * @param  {Any}    [options.data] Optional data to send as an arg when calling `method`
     * @constructor
     */

    function Action(target, method) {
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      _classCallCheck(this, Action);

      this.target = target;
      this.method = method;
      this.meta = options.meta;
      this.data = options.data;

      this.reset();
    }

    _createClass(Action, [{
      key: 'reset',
      value: function reset() {
        var _this = this;

        this._started = false;
        this._settled = false;
        this._resolution = new Orbit['default'].Promise(function (resolve, reject) {
          _this._success = function (r) {
            _this._settled = true;
            resolve(r);
          };

          _this._fail = function (e) {
            _this._settled = true;
            reject(e);
          };
        });
      }
    }, {
      key: 'settle',
      value: function settle() {
        return this._resolution;
      }
    }, {
      key: 'process',
      value: function process() {
        if (!this._started) {
          this._started = true;

          try {
            var method = this.target[this.method];

            var ret = undefined;
            if (this.data) {
              ret = method.call(this.target, this.data);
            } else {
              ret = method.call(this.target);
            }

            if (ret && ret.then) {
              ret.then(this._success, this._fail);
            } else {
              this._success(ret);
            }
          } catch (e) {
            this._fail(e);
          }
        }

        return this.settle();
      }
    }, {
      key: 'serialize',
      value: function serialize() {
        var method = this.method;
        var data = this.data;
        var meta = this.meta;

        return { method: method, data: data, meta: meta };
      }
    }, {
      key: 'started',
      get: function get() {
        return this._started;
      }
    }, {
      key: 'settled',
      get: function get() {
        return this._settled;
      }
    }], [{
      key: 'deserialize',
      value: function deserialize(target, serialized) {
        return new Action(target, serialized.method, {
          data: serialized.data,
          meta: serialized.meta
        });
      }
    }]);

    return Action;
  })();

  exports['default'] = Action;
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/bucket', ['exports', 'orbit/main', 'orbit/evented', 'orbit/lib/assert'], function (exports, Orbit, Evented, assert) {

  'use strict';

  var Bucket = (function () {
    function Bucket() {
      var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _classCallCheck(this, Bucket);

      assert.assert('Bucket requires a name', settings.name);

      this._name = settings.name;

      if (settings.version === undefined) {
        settings.version = 1;
      }

      settings.namespace = settings.namespace || 'orbit-bucket';

      this._applySettings(settings);
    }

    _createClass(Bucket, [{
      key: 'upgrade',

      /**
       * Upgrades Bucket to a new version with new settings.
       *
       * Settings, beyond `version`, are bucket-specific.
       *
       * @param  {Object}   [settings={}]      Settings.
       * @param  {Integer}  [settings.version] Optional. Version. Defaults to the current version + 1.
       * @return {Promise}                     Promise that resolves when upgrade has completed.
       */
      value: function upgrade() {
        var _this = this;

        var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (settings.version === undefined) {
          settings.version = this._version + 1;
        }
        return this._applySettings(settings).then(function () {
          return _this.emit('upgrade', _this._version);
        });
      }

      /**
       * Applies settings passed from a `constructor` or `upgrade`.
       *
       * @private
       * @param  {Object}   settings          Settings.
       * @param  {Integer}  settings.version  Bucket version.
       * @return {Promise}                    Promise that resolves when settings have been applied.
       */
    }, {
      key: '_applySettings',
      value: function _applySettings(settings) {
        if (settings.namespace) {
          this._namespace = settings.namespace;
        }
        this._version = settings.version;
        return Orbit['default'].Promise.resolve();
      }
    }, {
      key: 'getItem',
      value: function getItem() /* key */{
        console.error('Bucket#getItem not implemented');
      }
    }, {
      key: 'setItem',
      value: function setItem() /* key, value */{
        console.error('Bucket#setItem not implemented');
      }
    }, {
      key: 'removeItem',
      value: function removeItem() /* key */{
        console.error('Bucket#removeItem not implemented');
      }
    }, {
      key: 'name',
      get: function get() {
        return this._name;
      }
    }, {
      key: 'namespace',
      get: function get() {
        return this._namespace;
      }
    }, {
      key: 'version',
      get: function get() {
        return this._version;
      }
    }]);

    return Bucket;
  })();

  exports['default'] = Bucket;

  Evented['default'].extend(Bucket.prototype);
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/coordinator', ['exports', 'orbit/main', 'orbit/lib/assert'], function (exports, Orbit, assert) {

  'use strict';

  var Coordinator = (function () {
    function Coordinator() {
      var _this = this;

      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _classCallCheck(this, Coordinator);

      this._active = false;
      this._sources = [];
      this._transformListeners = {};

      if (options.sources) {
        options.sources.forEach(function (source) {
          return _this.addSource(source);
        });
      }

      if (options.autoActivate !== false) {
        this.activate();
      }
    }

    _createClass(Coordinator, [{
      key: 'addSource',
      value: function addSource(source) {
        assert.assert('Source \'' + source.name + '\' has already been added to the Coordinator.', this._sources.indexOf(source) === -1);

        this._sources.push(source);

        if (this._active) {
          this._activateSource(source);
        }
      }
    }, {
      key: 'removeSource',
      value: function removeSource(source) {
        assert.assert('Source \'' + source.name + '\' has not been added to the Coordinator.', this._sources.indexOf(source) > -1);

        if (this._active) {
          this._deactivateSource(source);
        }

        this._sources.pop(source);
      }
    }, {
      key: 'activate',
      value: function activate() {
        var _this2 = this;

        this.activated = this.review().then(function () {
          _this2._active = true;
          _this2._sources.forEach(function (source) {
            return _this2._activateSource(source);
          });
        });

        return this.activated;
      }
    }, {
      key: 'review',
      value: function review() {
        var _this3 = this;

        if (this._reviewing) {
          this._extraReviewNeeded = true;
        } else {
          this._reviewing = this._reifySources().then(function () {
            return _this3._review();
          }).then(function () {
            if (_this3._extraReviewNeeded) {
              _this3._extraReviewNeeded = false;
              return _this3._review();
            } else {
              _this3._reviewing = null;
            }
          });
        }
        return this._reviewing;
      }
    }, {
      key: 'deactivate',
      value: function deactivate() {
        var _this4 = this;

        this._active = false;
        this.activated = null;
        this._sources.forEach(function (source) {
          return _this4._deactivateSource(source);
        });
      }
    }, {
      key: '_reifySources',
      value: function _reifySources() {
        return this._sources.reduce(function (chain, source) {
          return chain.then(function () {
            return source.transformLog.reified;
          });
        }, Orbit['default'].Promise.resolve());
      }
    }, {
      key: '_review',
      value: function _review() {
        if (this._sources.length > 1) {
          var primaryLog = this._sources[0].transformLog;
          var otherLogs = this._sources.slice(1).map(function (s) {
            return s.transformLog;
          });
          var entries = primaryLog.entries;
          var latestMatch = undefined;

          for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];

            var match = true;
            for (var j = 0; j < otherLogs.length; j++) {
              if (!otherLogs[j].contains(entry)) {
                match = false;
                break;
              }
            }

            if (match) {
              latestMatch = entry;
            } else {
              break;
            }
          }

          if (latestMatch) {
            return this._truncateSources(latestMatch, +1);
          }
        }
        return Orbit['default'].Promise.resolve();
      }
    }, {
      key: '_truncateSources',
      value: function _truncateSources(transformId, relativePosition) {
        return this._sources.reduce(function (chain, source) {
          return chain.then(function () {
            return source.transformLog.truncate(transformId, relativePosition);
          });
        }, Orbit['default'].Promise.resolve());
      }
    }, {
      key: '_activateSource',
      value: function _activateSource(source) {
        var _this5 = this;

        var listener = this._transformListeners[source.name] = function (transform) {
          _this5._sourceTransformed(source, transform.id);
        };
        source.on('transform', listener);
      }
    }, {
      key: '_deactivateSource',
      value: function _deactivateSource(source) {
        source.off('transform', this._transformListeners[source.name]);
      }
    }, {
      key: '_sourceTransformed',
      value: function _sourceTransformed() /* source, transformId */{
        this.review();
      }
    }, {
      key: 'active',
      get: function get() {
        return this._active;
      }
    }]);

    return Coordinator;
  })();

  exports['default'] = Coordinator;
});
'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

define('orbit/evented', ['exports', 'orbit/main', 'orbit/notifier', 'orbit/lib/assert', 'orbit/lib/objects'], function (exports, Orbit, Notifier, assert, objects) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Evented` interface into an object
      @method extend
     @param {Object} object Object to extend
     @returns {Object} Extended object
     */
    extend: function extend(object) {
      assert.assert('Evented requires Orbit.Promise be defined', Orbit['default'].Promise);

      if (object._evented === undefined) {
        objects.extend(object, this['interface']);
      }

      return object;
    },

    'interface': {
      _evented: true,

      on: function on(eventName, callback, _binding) {
        var binding = _binding || this;

        notifierForEvent(this, eventName, true).addListener(callback, binding);
      },

      off: function off(eventName, callback, _binding) {
        var binding = _binding || this;
        var notifier = notifierForEvent(this, eventName);

        if (notifier) {
          if (callback) {
            notifier.removeListener(callback, binding);
          } else {
            removeNotifierForEvent(this, eventName);
          }
        }
      },

      one: function one(eventName, callback, _binding) {
        var callOnce = undefined;
        var notifier = undefined;
        var binding = _binding || this;

        notifier = notifierForEvent(this, eventName, true);

        callOnce = function () {
          callback.apply(binding, arguments);
          notifier.removeListener(callOnce, binding);
        };

        notifier.addListener(callOnce, binding);
      },

      emit: function emit(eventName) {
        var notifier = notifierForEvent(this, eventName);

        if (notifier) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          notifier.emit.apply(notifier, args);
        }
      },

      listeners: function listeners(eventName) {
        var notifier = notifierForEvent(this, eventName);

        return notifier ? notifier.listeners : [];
      },

      settleInSeries: function settleInSeries(eventName) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        var listeners = this.listeners(eventName);

        return listeners.reduce(function (chain, _ref) {
          var _ref2 = _slicedToArray(_ref, 2);

          var callback = _ref2[0];
          var binding = _ref2[1];

          return chain.then(function () {
            return callback.apply(binding, args);
          })['catch'](function (e) {
            console.error('Orbit ignored error in event listener', eventName);
            console.error(e.stack || e);
          });
        }, Orbit['default'].Promise.resolve());
      },

      fulfillInSeries: function fulfillInSeries(eventName) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        var listeners = this.listeners(eventName);

        return new Orbit['default'].Promise(function (resolve, reject) {
          fulfillEach(listeners, args, resolve, reject);
        });
      }
    }
  };

  function notifierForEvent(object, eventName, createIfUndefined) {
    if (object._eventedNotifiers === undefined) {
      object._eventedNotifiers = {};
    }
    var notifier = object._eventedNotifiers[eventName];
    if (!notifier && createIfUndefined) {
      notifier = object._eventedNotifiers[eventName] = new Notifier['default']();
    }
    return notifier;
  }

  function removeNotifierForEvent(object, eventName) {
    if (object._eventedNotifiers && object._eventedNotifiers[eventName]) {
      delete object._eventedNotifiers[eventName];
    }
  }

  function fulfillEach(listeners, args, resolve, reject) {
    if (listeners.length === 0) {
      resolve();
    } else {
      var listener = undefined;
      var _listeners = listeners;

      var _listeners2 = _toArray(_listeners);

      listener = _listeners2[0];
      listeners = _listeners2.slice(1);
      var _listener = listener;

      var _listener2 = _slicedToArray(_listener, 2);

      var callback = _listener2[0];
      var binding = _listener2[1];

      var response = callback.apply(binding, args);

      if (response) {
        return Orbit['default'].Promise.resolve(response).then(function () {
          return fulfillEach(listeners, args, resolve, reject);
        })['catch'](function (error) {
          return reject(error);
        });
      } else {
        fulfillEach(listeners, args, resolve, reject);
      }
    }
  }
});
'use strict';

define('orbit', ['exports', 'orbit/main'], function (exports, Orbit) {

	'use strict';

	exports['default'] = Orbit['default'];
});
'use strict';

define('orbit/interfaces/pullable', ['exports', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit/source'], function (exports, assert, objects, Source) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Pullable` interface into a source.
      The `Pullable` interface adds a single method to a Source: `pull`. This
     method accepts a `Query` instance as an argument and returns a promise
     that resolves to an array of `Transform` instances that represent the
     changeset that resulted from applying the query. In other words, a `pull`
     request retrieves the results of a query in `Transform` form.
      This interface is part of the "request flow" in Orbit. Requests trigger
     events before and after processing of each request. Observers can delay the
     resolution of a request by returning a promise in an event listener.
      The `Pullable` interface introduces the following events:
      * `beforePull` - emitted prior to the processing of `pull`, this event
       includes the requested `Query` as an argument.
      * `pull` - emitted after a `pull` has successfully been requested, this
       event's arguments include both the requested `Query` and an array of
       the resulting `Transform` instances.
      * `pullFail` - emitted when an error has occurred processing a `pull`, this
       event's arguments include both the requested `Query` and the error.
      A `Pullable` source must implement a private method `_pull`, which performs
     the processing required for `pull` and returns a promise that resolves to an
     array of `Transform` instances.
      @method extend
     @param {Object} source - Source to extend
     @returns {Object} Extended source
     */
    extend: function extend(source) {
      if (source._pullable === undefined) {
        assert.assert('Pullable interface can only be applied to a Source', source instanceof Source['default']);
        objects.extend(source, this['interface']);
      }
      return source;
    },

    'interface': {
      _pullable: true,

      pull: function pull(query) {
        return this._enqueueRequest('pull', query);
      },

      __pull__: function __pull__(query) {
        var _this = this;

        return this.fulfillInSeries('beforePull', query).then(function () {
          return _this._pull(query);
        }).then(function (result) {
          return _this._transformed(result);
        }).then(function (result) {
          return _this.settleInSeries('pull', query, result).then(function () {
            return result;
          });
        })['catch'](function (error) {
          return _this.settleInSeries('pullFail', query, error).then(function () {
            throw error;
          });
        });
      }
    }
  };
});
'use strict';

define('orbit/interfaces/pushable', ['exports', 'orbit/main', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit/source'], function (exports, Orbit, assert, objects, Source) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Pushable` interface into a source.
      The `Pushable` interface adds a single method to a Source: `push`. This
     method accepts a `Transform` instance as an argument and returns a promise
     that resolves to an array of `Transform` instances that are applied as a
     result. In other words, `push` captures the direct and side effects of
     applying a `Transform` to a source.
      This interface is part of the "request flow" in Orbit. Requests trigger
     events before and after processing of each request. Observers can delay the
     resolution of a request by returning a promise in an event listener.
      The `Pushable` interface introduces the following events:
      * `beforePush` - emitted prior to the processing of `push`, this event
       includes the requested `Transform` as an argument.
      * `push` - emitted after a `push` has successfully been applied, this
       event's arguments include both the requested `Transform` and an array of
       the actual applied `Transform` instances.
      * `pushFail` - emitted when an error has occurred pushing a transform, this
       event's arguments include both the requested `Transform` and the error.
      A `Pushable` source must implement a private method `_push`, which performs
     the processing required for `push` and returns a promise that resolves to an
     array of `Transform` instances.
      @method extend
     @param {Object} source - Source to extend
     @returns {Object} Extended source
     */
    extend: function extend(source) {
      if (source._pushable === undefined) {
        assert.assert('Pushable interface can only be applied to a Source', source instanceof Source['default']);
        objects.extend(source, this['interface']);
      }
      return source;
    },

    'interface': {
      _pushable: true,

      push: function push(transform) {
        if (this.transformLog.contains(transform.id)) {
          return Orbit['default'].Promise.resolve([]);
        }

        return this._enqueueRequest('push', transform);
      },

      __push__: function __push__(transform) {
        var _this = this;

        if (this.transformLog.contains(transform.id)) {
          return Orbit['default'].Promise.resolve([]);
        }

        return this.fulfillInSeries('beforePush', transform).then(function () {
          return _this._push(transform);
        }).then(function (result) {
          return _this._transformed(result);
        }).then(function (result) {
          return _this.settleInSeries('push', transform, result).then(function () {
            return result;
          });
        })['catch'](function (error) {
          return _this.settleInSeries('pushFail', transform, error).then(function () {
            throw error;
          });
        });
      }
    }
  };
});
'use strict';

define('orbit/interfaces/queryable', ['exports', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit/query', 'orbit/source'], function (exports, assert, objects, Query, Source) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Queryable` interface into a source.
      The `Queryable` interface adds a single method to a source: `query`. This
     method accepts a `Query` instance or query expression which it then converts
     to a `Query` instance. The source evaluates the query and returns a promise
     that resolves to a static set of results.
      This interface is part of the "request flow" in Orbit. Requests trigger events
     before and after processing of each request. Observers can delay the
     resolution of a request by returning a promise in an event listener.
      The `Queryable` interface introduces the following events:
      * `beforeQuery` - emitted prior to the processing of `query`, this event
       includes the requested `Query` as an argument.
      * `query` - emitted after a `query` has successfully returned, this
       event's arguments include both the requested `Query` and the results.
      * `queryFail` - emitted when an error has occurred processing a query, this
       event's arguments include both the requested `Query` and the error.
      A `Queryable` source must implement a private method `_query`, which performs
     the processing required for `query` and returns a promise that resolves to a
     set of results.
      @method extend
     @param {Object} source - Source to extend
     @returns {Object} Extended source
     */
    extend: function extend(source) {
      if (source._queryable === undefined) {
        assert.assert('Queryable interface can only be applied to a Source', source instanceof Source['default']);
        objects.extend(source, this['interface']);
      }
      return source;
    },

    'interface': {
      _queryable: true,

      query: function query(queryOrExpression) {
        var query = Query['default'].from(queryOrExpression, this.queryBuilder);
        return this._enqueueRequest('query', query);
      },

      __query__: function __query__(query) {
        var _this = this;

        return this.fulfillInSeries('beforeQuery', query).then(function () {
          return _this._query(query);
        }).then(function (result) {
          return _this.settleInSeries('query', query, result).then(function () {
            return result;
          });
        })['catch'](function (error) {
          return _this.settleInSeries('queryFail', query, error).then(function () {
            throw error;
          });
        });
      }
    }
  };
});
'use strict';

define('orbit/interfaces/syncable', ['exports', 'orbit/main', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit/source'], function (exports, Orbit, assert, objects, Source) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Syncable` interface into a source.
      The `Syncable` interface adds the `sync` method to a source. This method
     accepts a `Transform` or array of `Transform`s as an argument and applies it
     to the source.
      This interface is part of the "sync flow" in Orbit. This flow is used to
     synchronize the contents of sources.
      Other sources can participate in the resolution of a `sync` by observing
     the `transform` event, which is emitted whenever a new `Transform` is
     applied to a source.
      @method extend
     @param {Object} source - Source to extend
     @returns {Object} Extended source
     */
    extend: function extend(source) {
      if (source._syncable === undefined) {
        assert.assert('Syncable interface can only be applied to a Source', source instanceof Source['default']);
        objects.extend(source, this['interface']);
      }
      return source;
    },

    'interface': {
      _syncable: true,

      sync: function sync(transformOrTransforms) {
        var _this = this;

        if (objects.isArray(transformOrTransforms)) {
          var transforms = transformOrTransforms;

          return transforms.reduce(function (chain, transform) {
            return chain.then(function () {
              return _this.sync(transform);
            });
          }, Orbit['default'].Promise.resolve());
        } else {
          var transform = transformOrTransforms;

          if (this.transformLog.contains(transform.id)) {
            return Orbit['default'].Promise.resolve();
          }

          return this._enqueueSync('sync', transform);
        }
      },

      __sync__: function __sync__(transform) {
        var _this2 = this;

        if (this.transformLog.contains(transform.id)) {
          return Orbit['default'].Promise.resolve();
        }

        return this._sync(transform).then(function () {
          return _this2._transformed([transform]);
        });
      }
    }
  };
});
'use strict';

define('orbit/interfaces/updatable', ['exports', 'orbit/main', 'orbit/lib/assert', 'orbit/lib/objects', 'orbit/transform', 'orbit/source'], function (exports, Orbit, assert, objects, Transform, Source) {

  'use strict';

  exports['default'] = {
    /**
     Mixes the `Updatable` interface into a source.
      The `Updatable` interface adds a single method to a source: `update`. This
     method accepts a `Transform` instance or an array of operations which it then
     converts to a `Transform` instance. The source applies the update and returns
     a promise that resolves when complete.
      This interface is part of the "request flow" in Orbit. Requests trigger
     events before and after processing of each request. Observers can delay the
     resolution of a request by returning a promise in an event listener.
      The `Updatable` interface introduces the following events:
      * `beforeUpdate` - emitted prior to the processing of `update`, this event
       includes the requested `Transform` as an argument.
      * `update` - emitted after an `update` has successfully been applied, this
       event includes the requested `Transform` as an argument.
      * `updateFail` - emitted when an error has occurred applying an update, this
       event's arguments include both the requested `Transform` and the error.
      An `Updatable` source must implement a private method `_update`, which
     performs the processing required for `update` and returns a promise that
     resolves when complete.
      @method extend
     @param {Object} source - Source to extend
     @returns {Object} Extended source
     */
    extend: function extend(source) {
      if (source._updatable === undefined) {
        assert.assert('Updatable interface can only be applied to a Source', source instanceof Source['default']);
        objects.extend(source, this['interface']);
      }
      return source;
    },

    'interface': {
      _updatable: true,

      update: function update(transformOrOperations) {
        var transform = Transform['default'].from(transformOrOperations);

        if (this.transformLog.contains(transform.id)) {
          return Orbit['default'].Promise.resolve([]);
        }

        return this._enqueueRequest('update', transform);
      },

      __update__: function __update__(transform) {
        var _this = this;

        if (this.transformLog.contains(transform.id)) {
          return Orbit['default'].Promise.resolve([]);
        }

        return this.fulfillInSeries('beforeUpdate', transform).then(function () {
          return _this._update(transform);
        }).then(function () {
          return _this._transformed([transform]);
        }).then(function () {
          return _this.settleInSeries('update', transform);
        })['catch'](function (error) {
          return _this.settleInSeries('updateFail', transform, error).then(function () {
            throw error;
          });
        });
      }
    }
  };
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/key-map', ['exports', 'orbit/lib/objects', 'orbit/lib/arrays', 'orbit/lib/assert'], function (exports, objects, arrays, assert) {

  'use strict';

  var KeyMap = (function () {
    function KeyMap() {
      _classCallCheck(this, KeyMap);

      this._data = {};
    }

    /**
     Return a key value given a type of model, key name and id.
      @param {String} type - type of model
     @param {String} keyName - the name of the key
     @param {String} idValue - the model id
     @returns {string} the model's key value
     */

    _createClass(KeyMap, [{
      key: 'idToKey',
      value: function idToKey(type, keyName, idValue) {
        return objects.get(this._data, [type, keyName, 'idToKeyMap', idValue]);
      }

      /**
       Return an id value given a type of model, key name and key value.
        @param {String} type - type of model
       @param {String} keyName - the name of the key
       @param {String} keyValue - the value of the key to look up
       @returns {string} the model's id value
       */
    }, {
      key: 'keyToId',
      value: function keyToId(type, keyName, keyValue) {
        return objects.get(this._data, [type, keyName, 'keyToIdMap', keyValue]);
      }

      /**
       Given a data object structured according to this schema, register all of its
       key mappings. This data object may contain any number of records and types.
        @param {Object} document - data structured according to the schema
       @returns {undefined}
       */
    }, {
      key: 'pushDocument',
      value: function pushDocument(document) {
        var _this = this;

        if (!document) {
          return;
        }

        Object.keys(document).forEach(function (type) {
          var idRecordMap = document[type];
          Object.keys(idRecordMap).forEach(function (id) {
            var record = idRecordMap[id];
            _this.pushRecord({
              type: type,
              id: record.id,
              keys: record.keys
            });
          });
        });
      }

      /**
       Integrate the id and key values of a record into this keyMap.
        @param {Object} record - a data structure that represents a record
       @param {String} record.type - the type of model
       @param {String} record.id - the model's ID
       @param {Object} record.keys - a map of keys and their values
       @returns {undefined}
       */
    }, {
      key: 'pushRecord',
      value: function pushRecord(_ref) {
        var _this2 = this;

        var type = _ref.type;
        var id = _ref.id;
        var keys = _ref.keys;

        assert.assert('You pushed a ' + type + ' record into the KeyMap that does not have an ID. Make sure you provide an Orbit ID to this record before pushing.', id);

        if (!keys) {
          return;
        }

        Object.keys(keys).forEach(function (keyName) {
          var keyValue = keys[keyName];
          objects.set(_this2._data, [type, keyName, 'idToKeyMap', id], keyValue);
          objects.set(_this2._data, [type, keyName, 'keyToIdMap', keyValue], id);
        });
      }

      /**
       Given a record, find the cached ID if it exists.
        @param {Object} record - a data structure that represents a record
       @returns {String|undefined} either the ID value or nothing
       */
    }, {
      key: 'findIdForRecord',
      value: function findIdForRecord(record) {
        var _this3 = this;

        if (!record.keys) {
          return;
        }

        var keyNames = Object.keys(record.keys);

        return arrays.firstResult(keyNames, function (keyName) {
          var keyValue = record.keys[keyName];
          if (keyValue) {
            return _this3.keyToId(record.type, keyName, keyValue);
          }
        });
      }
    }]);

    return KeyMap;
  })();

  exports['default'] = KeyMap;
});
'use strict';

define('orbit/lib/arrays', ['exports'], function (exports) {

  'use strict';

  exports.every = every;
  exports.some = some;
  exports.firstResult = firstResult;

  /**
    Like the Lodash _.every function, this function takes an array and a
    predicate function and returns true or false depending on whether the
    predicate is true for every item in the array.
     @param {Array} array - array to iterate through
    @param {function} predicate - function that returns true or false
    @returns {boolean} determination of whether every predicate call was true
   */
  function every(array, predicate) {
    var index = -1;
    var length = array.length;

    while (++index < length) {
      if (!predicate(array[index], index)) {
        return false;
      }
    }

    return true;
  }

  /**
    Like the Lodash _.some function, this function takes an array and a predicate
    function and returns true or false depending on whether the predicate is true
    for any of the items in the array.
     @param {Array} array - array to iterate through
    @param {function} predicate - function that returns true or false
    @returns {boolean} determination of whether any predicate call was true
   */
  function some(array, predicate) {
    var index = -1;
    var length = array.length;

    while (++index < length) {
      if (predicate(array[index], index)) {
        return true;
      }
    }

    return false;
  }

  /**
    This function is similar to Array.prototype.find, but it returns the result
    of calling the value function rather than an item of the array.
     @param {Array} array - array to iterate through
    @param {function} valueFn - function that returns true or false
    @returns {*} the first result of valueFn that returned true or undefined
   */
  function firstResult(array, valueFn) {
    var index = -1;
    var length = array.length;

    while (++index < length) {
      var result = valueFn(array[index], index);
      if (result) {
        return result;
      }
    }
  }
});
'use strict';

define('orbit/lib/assert', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Throw an exception if `test` is not truthy.
    @method assert
   @for Orbit
   @param desc Description of the error thrown
   @param test Value that should be truthy for assertion to pass
   */
  var assert = function assert(desc, test) {
    if (!test) {
      throw new Error('Assertion failed: ' + desc);
    }
  };

  exports.assert = assert;
});
'use strict';

define('orbit/lib/config', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Converts an array of values to an object with those values as properties
   having a value of `true`.
    This is useful for converting an array of settings to a more efficiently
   accessible settings object.
    @example
    ``` javascript
   Orbit.arrayToOptions(['a', 'b']); // returns {a: true, b: true}
   ```
    @method arrayToOptions
   @for Orbit
   @param {Array} a
   @returns {Object} Set of options, keyed by the elements in `a`
   */
  var arrayToOptions = function arrayToOptions(a) {
    var options = {};
    if (a) {
      for (var i in a) {
        if (a.hasOwnProperty(i)) {
          options[a[i]] = true;
        }
      }
    }
    return options;
  };

  exports.arrayToOptions = arrayToOptions;
});
'use strict';

define('orbit/lib/deprecate', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Display a deprecation warning with the provided message.
    @method deprecate
   @for Orbit
   @param {String} message Description of the deprecation
   @param {Boolean} test An optional boolean. If false, the deprecation will be displayed.
   */
  var deprecate = function deprecate(message, test) {
    if (typeof test === 'function') {
      if (test()) {
        return;
      }
    } else {
      if (test) {
        return;
      }
    }
    console.warn(message);
  };

  exports.deprecate = deprecate;
});
'use strict';

define('orbit/lib/diffs', ['exports', 'orbit/lib/eq', 'orbit/lib/objects', 'orbit/lib/config'], function (exports, eq, objects, config) {

  'use strict';

  /* eslint-disable valid-jsdoc */
  var diffs = function diffs(a, b, options) {
    if (a === b) {
      return undefined;
    } else {
      options = options || {};

      var ignore = config.arrayToOptions(options.ignore);
      var basePath = options.basePath || '';

      if (objects.isArray(basePath)) {
        basePath = basePath.join('/');
      }

      var type = Object.prototype.toString.call(a);
      if (type === Object.prototype.toString.call(b)) {
        if (a !== null && typeof a === 'object') {
          var i, d;

          if (objects.isArray(a)) {
            var aLength = a.length;
            var bLength = b.length;
            var maxLength = bLength > aLength ? bLength : aLength;
            var match = undefined;
            var ai = 0;
            var bi = 0;
            var bj = undefined;

            for (i = 0; i < maxLength; i++) {
              if (ai >= aLength) {
                if (d === undefined) {
                  d = [];
                }
                d.push({ op: 'add', path: basePath + '/' + bi, value: objects.clone(b[bi]) });
                bi++;
              } else if (bi >= bLength) {
                if (d === undefined) {
                  d = [];
                }
                d.push({ op: 'remove', path: basePath + '/' + ai });
                ai++;
              } else if (!eq.eq(a[ai], b[bi])) {
                match = -1;
                for (bj = bi + 1; bj < bLength; bj++) {
                  if (eq.eq(a[ai], b[bj])) {
                    match = bj;
                    break;
                  }
                }
                if (match === -1) {
                  if (d === undefined) {
                    d = [];
                  }
                  d.push({ op: 'remove', path: basePath + '/' + ai });
                  ai++;
                } else {
                  if (d === undefined) {
                    d = [];
                  }
                  d.push({ op: 'add', path: basePath + '/' + bi, value: objects.clone(b[bi]) });
                  bi++;
                }
              } else {
                ai++;
                bi++;
              }
            }
          } else if (a instanceof Date) {
            if (a.getTime() === b.getTime()) {
              return;
            }
            if (d === undefined) {
              d = [];
            }
            d.push({ op: 'replace', path: basePath, value: objects.clone(b) });
          } else {
            // general (non-array) object
            for (i in b) {
              if (!ignore[i] && b.hasOwnProperty(i)) {
                if (a[i] === undefined) {
                  if (d === undefined) {
                    d = [];
                  }
                  d.push({ op: 'add', path: basePath + '/' + i, value: objects.clone(b[i]) });
                } else if (!eq.eq(a[i], b[i])) {
                  if (d === undefined) {
                    d = [];
                  }
                  d = d.concat(diffs(a[i], b[i], { basePath: basePath + '/' + i }));
                }
              }
            }

            for (i in a) {
              if (!ignore[i] && a.hasOwnProperty(i)) {
                if (b[i] === undefined) {
                  if (d === undefined) {
                    d = [];
                  }
                  d.push({ op: 'remove', path: basePath + '/' + i });
                }
              }
            }
          }

          return d;
        } else if (eq.eq(a, b)) {
          return undefined;
        }
      }

      return [{ op: 'replace', path: basePath, value: objects.clone(b) }];
    }
  };

  exports.diffs = diffs;
});
'use strict';

define('orbit/lib/eq', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable eqeqeq, no-eq-null, valid-jsdoc */

  /**
   `eq` checks the equality of two objects.
    The properties belonging to objects (but not their prototypes) will be
   traversed deeply and compared.
    Includes special handling for strings, numbers, dates, booleans, regexes, and
   arrays.
    @method eq
   @for Orbit
   @param a
   @param b
   @returns {Boolean} are `a` and `b` equal?
   */
  var eq = function eq(a, b) {
    // Some elements of this function come from underscore
    // (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //
    // https://github.com/jashkenas/underscore/blob/master/underscore.js

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) {
      return a !== 0 || 1 / a == 1 / b;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) {
      return a === b;
    }

    var type = Object.prototype.toString.call(a);
    if (type !== Object.prototype.toString.call(b)) {
      return false;
    }

    switch (type) {
      case '[object String]':
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') {
      return false;
    }

    if (type === '[object Array]') {
      if (a.length !== b.length) {
        return false;
      }
    }

    var i;
    for (i in b) {
      if (b.hasOwnProperty(i)) {
        if (!eq(a[i], b[i])) {
          return false;
        }
      }
    }
    for (i in a) {
      if (a.hasOwnProperty(i)) {
        if (!eq(a[i], b[i])) {
          return false;
        }
      }
    }
    return true;
  };

  exports.eq = eq;
});
'use strict';

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/lib/exceptions', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Base Exception
    @class Exception
   @namespace Orbit
   @constructor
   */

  var Exception = function Exception(message) {
    _classCallCheck(this, Exception);

    this.message = message;
    this.error = new Error(this.message);
    this.stack = this.error.stack;
  }

  /**
   Exception thrown when a path in a document can not be found.
    @class PathNotFoundException
   @namespace Orbit
   @param {String} path
   @constructor
   */
  ;

  var PathNotFoundException = (function (_Exception) {
    _inherits(PathNotFoundException, _Exception);

    function PathNotFoundException(path) {
      _classCallCheck(this, PathNotFoundException);

      _get(Object.getPrototypeOf(PathNotFoundException.prototype), 'constructor', this).call(this, 'Path not found: ' + path.join('/'));
      this.path = path;
    }

    return PathNotFoundException;
  })(Exception);

  var TransformNotLoggedException = (function (_Exception2) {
    _inherits(TransformNotLoggedException, _Exception2);

    function TransformNotLoggedException(transformId) {
      _classCallCheck(this, TransformNotLoggedException);

      _get(Object.getPrototypeOf(TransformNotLoggedException.prototype), 'constructor', this).call(this, 'Transform not logged: ' + transformId);
      this.transformId = transformId;
    }

    return TransformNotLoggedException;
  })(Exception);

  var QueryBuilderNotRegisteredException = (function (_Exception3) {
    _inherits(QueryBuilderNotRegisteredException, _Exception3);

    function QueryBuilderNotRegisteredException(queryBuilder) {
      _classCallCheck(this, QueryBuilderNotRegisteredException);

      _get(Object.getPrototypeOf(QueryBuilderNotRegisteredException.prototype), 'constructor', this).call(this, 'QueryBuilder not registered: ' + queryBuilder);
      this.queryBuilder = queryBuilder;
    }

    return QueryBuilderNotRegisteredException;
  })(Exception);

  var OutOfRangeException = (function (_Exception4) {
    _inherits(OutOfRangeException, _Exception4);

    function OutOfRangeException(value) {
      _classCallCheck(this, OutOfRangeException);

      _get(Object.getPrototypeOf(OutOfRangeException.prototype), 'constructor', this).call(this, 'Out of range: ' + value);
      this.value = value;
    }

    /**
     Exception thrown when an operation is not allowed.
      @class OperationNotAllowed
     @param {Object} description
     @constructor
     */
    return OutOfRangeException;
  })(Exception);

  var OperationNotAllowed = (function (_Exception5) {
    _inherits(OperationNotAllowed, _Exception5);

    function OperationNotAllowed(operation) {
      _classCallCheck(this, OperationNotAllowed);

      _get(Object.getPrototypeOf(OperationNotAllowed.prototype), 'constructor', this).call(this, 'Operation not allowed: ' + operation);
      this.operation = operation;
    }

    return OperationNotAllowed;
  })(Exception);

  var TransformNotAllowed = (function (_Exception6) {
    _inherits(TransformNotAllowed, _Exception6);

    function TransformNotAllowed(transform) {
      _classCallCheck(this, TransformNotAllowed);

      _get(Object.getPrototypeOf(TransformNotAllowed.prototype), 'constructor', this).call(this, 'Transform not allowed: ' + transform);
      this.transform = transform;
    }

    return TransformNotAllowed;
  })(Exception);

  var QueryNotAllowed = (function (_Exception7) {
    _inherits(QueryNotAllowed, _Exception7);

    function QueryNotAllowed(query) {
      _classCallCheck(this, QueryNotAllowed);

      _get(Object.getPrototypeOf(QueryNotAllowed.prototype), 'constructor', this).call(this, 'Query not allowed: ' + query);
      this.query = query;
    }

    return QueryNotAllowed;
  })(Exception);

  var QueryExpressionParseError = (function (_Exception8) {
    _inherits(QueryExpressionParseError, _Exception8);

    function QueryExpressionParseError(expression) {
      _classCallCheck(this, QueryExpressionParseError);

      _get(Object.getPrototypeOf(QueryExpressionParseError.prototype), 'constructor', this).call(this, 'Query expression parse error: ' + expression);
      this.expression = expression;
    }

    return QueryExpressionParseError;
  })(Exception);

  var UpdateNotAllowed = (function (_Exception9) {
    _inherits(UpdateNotAllowed, _Exception9);

    function UpdateNotAllowed(transform) {
      _classCallCheck(this, UpdateNotAllowed);

      _get(Object.getPrototypeOf(UpdateNotAllowed.prototype), 'constructor', this).call(this, 'Update not allowed: ' + transform);
      this.transform = transform;
    }

    return UpdateNotAllowed;
  })(Exception);

  var ModelNotRegisteredException = (function (_Exception10) {
    _inherits(ModelNotRegisteredException, _Exception10);

    function ModelNotRegisteredException(model) {
      _classCallCheck(this, ModelNotRegisteredException);

      _get(Object.getPrototypeOf(ModelNotRegisteredException.prototype), 'constructor', this).call(this, 'Model not registered: ' + model);
      this.model = model;
    }

    return ModelNotRegisteredException;
  })(Exception);

  var KeyNotRegisteredException = (function (_Exception11) {
    _inherits(KeyNotRegisteredException, _Exception11);

    function KeyNotRegisteredException(model, key) {
      _classCallCheck(this, KeyNotRegisteredException);

      _get(Object.getPrototypeOf(KeyNotRegisteredException.prototype), 'constructor', this).call(this, 'Key not registered: \'' + model + '#' + key + '\'');
      this.model = model;
      this.key = key;
    }

    return KeyNotRegisteredException;
  })(Exception);

  var RelationshipNotRegisteredException = (function (_Exception12) {
    _inherits(RelationshipNotRegisteredException, _Exception12);

    function RelationshipNotRegisteredException(model, relationship) {
      _classCallCheck(this, RelationshipNotRegisteredException);

      _get(Object.getPrototypeOf(RelationshipNotRegisteredException.prototype), 'constructor', this).call(this, 'Relationship not registered: \'' + model + '#' + relationship + '\'');
      this.model = model;
      this.relationship = relationship;
    }

    return RelationshipNotRegisteredException;
  })(Exception);

  var ClientError = (function (_Exception13) {
    _inherits(ClientError, _Exception13);

    function ClientError(description) {
      _classCallCheck(this, ClientError);

      _get(Object.getPrototypeOf(ClientError.prototype), 'constructor', this).call(this, 'Client error: ' + description);
    }

    return ClientError;
  })(Exception);

  var ServerError = (function (_Exception14) {
    _inherits(ServerError, _Exception14);

    function ServerError(description) {
      _classCallCheck(this, ServerError);

      _get(Object.getPrototypeOf(ServerError.prototype), 'constructor', this).call(this, 'Server error: ' + description);
    }

    return ServerError;
  })(Exception);

  var NetworkError = (function (_Exception15) {
    _inherits(NetworkError, _Exception15);

    function NetworkError(description) {
      _classCallCheck(this, NetworkError);

      _get(Object.getPrototypeOf(NetworkError.prototype), 'constructor', this).call(this, 'Network error: ' + description);
    }

    return NetworkError;
  })(Exception);

  var _RecordException = (function (_Exception16) {
    _inherits(_RecordException, _Exception16);

    function _RecordException(description, type, id, relationship) {
      _classCallCheck(this, _RecordException);

      var message = description + ': ' + type + ':' + id;

      if (relationship) {
        message += '/' + relationship;
      }

      _get(Object.getPrototypeOf(_RecordException.prototype), 'constructor', this).call(this, message);

      this.type = type;
      this.id = id;
      this.relationship = relationship;
    }

    /**
     Exception thrown when a record can not be found.
      @class RecordNotFoundException
     @param {String} type
     @param {String} id
     @constructor
     */
    return _RecordException;
  })(Exception);

  var RecordNotFoundException = (function (_RecordException2) {
    _inherits(RecordNotFoundException, _RecordException2);

    function RecordNotFoundException(type, id) {
      _classCallCheck(this, RecordNotFoundException);

      _get(Object.getPrototypeOf(RecordNotFoundException.prototype), 'constructor', this).call(this, 'Record not found', type, id);
    }

    /**
     Exception thrown when a relationship can not be found.
      @class RelationshipNotFoundException
     @namespace OC
     @param {String} type
     @param {String} id
     @constructor
     */
    return RecordNotFoundException;
  })(_RecordException);

  var RelationshipNotFoundException = (function (_RecordException3) {
    _inherits(RelationshipNotFoundException, _RecordException3);

    function RelationshipNotFoundException(type, id, relationship) {
      _classCallCheck(this, RelationshipNotFoundException);

      _get(Object.getPrototypeOf(RelationshipNotFoundException.prototype), 'constructor', this).call(this, 'Relationship not found', type, id, relationship);
    }

    /**
     Exception thrown when a record already exists.
      @class RecordAlreadyExistsException
     @namespace OC
     @param {String} type
     @param {Object} record
     @constructor
     */
    return RelationshipNotFoundException;
  })(_RecordException);

  var RecordAlreadyExistsException = (function (_RecordException4) {
    _inherits(RecordAlreadyExistsException, _RecordException4);

    function RecordAlreadyExistsException(type, id) {
      _classCallCheck(this, RecordAlreadyExistsException);

      _get(Object.getPrototypeOf(RecordAlreadyExistsException.prototype), 'constructor', this).call(this, 'Record already exists', type, id);
    }

    return RecordAlreadyExistsException;
  })(_RecordException);

  exports.Exception = Exception;
  exports.PathNotFoundException = PathNotFoundException;
  exports.TransformNotLoggedException = TransformNotLoggedException;
  exports.QueryBuilderNotRegisteredException = QueryBuilderNotRegisteredException;
  exports.OutOfRangeException = OutOfRangeException;
  exports.OperationNotAllowed = OperationNotAllowed;
  exports.TransformNotAllowed = TransformNotAllowed;
  exports.QueryNotAllowed = QueryNotAllowed;
  exports.QueryExpressionParseError = QueryExpressionParseError;
  exports.UpdateNotAllowed = UpdateNotAllowed;
  exports.ModelNotRegisteredException = ModelNotRegisteredException;
  exports.KeyNotRegisteredException = KeyNotRegisteredException;
  exports.RelationshipNotRegisteredException = RelationshipNotRegisteredException;
  exports.ClientError = ClientError;
  exports.ServerError = ServerError;
  exports.NetworkError = NetworkError;
  exports.RecordNotFoundException = RecordNotFoundException;
  exports.RelationshipNotFoundException = RelationshipNotFoundException;
  exports.RecordAlreadyExistsException = RecordAlreadyExistsException;
});
'use strict';

define('orbit/lib/functions', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Wraps a function that expects parameters with another that can accept the parameters as an array
    @method spread
   @for Orbit
   @param {Object} func
   @returns {function}
   */
  var spread = function spread(func) {
    return function (args) {
      func.apply(null, args);
    };
  };

  exports.spread = spread;
});
'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

define('orbit/lib/identifiers', ['exports', 'orbit/lib/objects'], function (exports, objects) {

  'use strict';

  exports.toIdentifier = toIdentifier;
  exports.parseIdentifier = parseIdentifier;
  exports.identity = identity;
  exports.eqIdentity = eqIdentity;

  function toIdentifier(type, id) {
    if (type) {
      if (objects.isObject(type)) {
        return type.type + ':' + type.id;
      } else {
        return type + ':' + id;
      }
    } else {
      return null;
    }
  }

  function parseIdentifier(identifier) {
    var _identifier$split = identifier.split(':');

    var _identifier$split2 = _slicedToArray(_identifier$split, 2);

    var type = _identifier$split2[0];
    var id = _identifier$split2[1];

    return { type: type, id: id };
  }

  function identity(record) {
    var type = record.type;
    var id = record.id;

    return { type: type, id: id };
  }

  function eqIdentity(record1, record2) {
    return objects.isNone(record1) && objects.isNone(record2) || objects.isObject(record1) && objects.isObject(record2) && record1.type === record2.type && record1.id === record2.id;
  }
});
'use strict';

define('orbit/lib/objects', ['exports'], function (exports) {

  'use strict';

  exports.get = get;
  exports.set = set;

  /* eslint-disable valid-jsdoc */

  /**
   Creates a deeply nested clone of an object.
    Traverses all object properties (but not prototype properties).
    @method clone
   @for Orbit
   @param {Object} obj
   @returns {Object} Clone of the original object
   */
  var clone = function clone(obj) {
    if (obj === undefined || obj === null || typeof obj !== 'object') {
      return obj;
    }

    var dup = undefined;
    var type = Object.prototype.toString.call(obj);

    if (type === '[object Date]') {
      dup = new Date();
      dup.setTime(obj.getTime());
    } else if (type === '[object RegExp]') {
      dup = obj.constructor(obj);
    } else if (type === '[object Array]') {
      dup = [];
      for (var i = 0, len = obj.length; i < len; i++) {
        if (obj.hasOwnProperty(i)) {
          dup.push(clone(obj[i]));
        }
      }
    } else {
      var val;

      dup = {};
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === 'object') {
            val = clone(val);
          }
          dup[key] = val;
        }
      }
    }
    return dup;
  };

  /**
   Expose properties and methods from one object on another.
    Methods will be called on `source` and will maintain `source` as the
   context.
    @method expose
   @for Orbit
   @param {Object} destination
   @param {Object} source
   */
  var expose = function expose(destination, source) {
    var properties;
    if (arguments.length > 2) {
      properties = Array.prototype.slice.call(arguments, 2);
    } else {
      properties = Object.keys(source);
    }

    properties.forEach(function (p) {
      if (typeof source[p] === 'function') {
        destination[p] = function () {
          return source[p].apply(source, arguments);
        };
      } else {
        destination[p] = source[p];
      }
    });
  };

  /**
   Extend an object with the properties of one or more other objects.
    @method extend
   @for Orbit
   @param {Object} destination The object to merge into
   @param {Object} source One or more source objects
   */
  var extend = function extend(destination) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function (source) {
      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          destination[p] = source[p];
        }
      }
    });
    return destination;
  };

  /**
   Checks whether an object is an instance of an `Array`
    @method isArray
   @for Orbit
   @param {Object} obj
   @returns {boolean}
   */
  var isArray = function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  /**
   Converts an object to an `Array` if it's not already.
    @method toArray
   @for Orbit
   @param {Object} obj
   @returns {Array}
   */
  var toArray = function toArray(obj) {
    if (isNone(obj)) {
      return [];
    } else {
      return isArray(obj) ? obj : [obj];
    }
  };

  /**
   Checks whether a value is a non-null object
    @method isObject
   @for Orbit
   @param {Object} obj
   @returns {boolean}
   */
  var isObject = function isObject(obj) {
    return obj !== null && typeof obj === 'object';
  };

  /**
   Checks whether an object is null or undefined
    @method isNone
   @for Orbit
   @param {Object} obj
   @returns {boolean}
   */
  var isNone = function isNone(obj) {
    return obj === undefined || obj === null;
  };

  /**
   Combines two objects values
    @method merge
   @for Orbit
   @param {Object} base
   @param {Object} source
   @returns {Object}
   */
  var merge = function merge(base, source) {
    var merged = clone(base);
    if (source) {
      Object.keys(source).forEach(function (field) {
        if (source.hasOwnProperty(field)) {
          var fieldDef = source[field];
          merged[field] = fieldDef;
        }
      });
    }

    return merged;
  };

  /**
    Similar to the lodash _.get function, this function uses a path to retrieve a
    value from a nested object.
     @param {Object} obj - object to pull values from
    @param {string[]} path - any array of strings specifying the path to use
    @returns {*} the value of the obj at path or undefined
   */
  function get(obj, path) {
    var index = -1;
    var result = obj;

    while (++index < path.length) {
      result = result[path[index]];
      if (!result) {
        return result;
      }
    }

    return result;
  }

  /**
    Similar to the Lodash _.set function, this function uses a path to set a
    value on an object. This function will create objects along the path if
    necessary to allow setting a deeply nested value.
     @param {Object} obj - object to set values in
    @param {string[]} path - any array of strings specifying the path to use
    @param {*} value - the value to set
    @returns {undefined}
   */
  function set(obj, path, value) {
    var index = -1;
    var length = path.length;
    var lastIndex = length - 1;
    var nested = obj;

    /* eslint-disable no-eq-null, eqeqeq */
    while (nested != null && ++index < length) {
      var key = path[index];

      if (typeof nested === 'object') {
        var newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];

          if (objValue == null) {
            newValue = typeof path[index + 1] === 'number' ? [] : {};
          } else {
            newValue = objValue;
          }
        }

        nested[key] = newValue;
      }

      nested = nested[key];
    }
    /* eslint-enable no-eq-null, eqeqeq */
  }

  exports.clone = clone;
  exports.expose = expose;
  exports.extend = extend;
  exports.isArray = isArray;
  exports.toArray = toArray;
  exports.isObject = isObject;
  exports.isNone = isNone;
  exports.merge = merge;
});
'use strict';

define('orbit/lib/operations', ['exports', 'orbit/lib/eq', 'orbit/lib/identifiers'], function (exports, eq, identifiers) {

  'use strict';

  exports.coalesceOperations = coalesceOperations;
  exports.recordDiffs = recordDiffs;

  /* eslint-disable valid-jsdoc */
  function mergeOps(superceded, superceding, consecutiveOps) {
    if (identifiers.eqIdentity(superceded.record, superceding.record)) {
      if (superceding.op === 'removeRecord') {
        superceded._deleted = true;
        if (superceded.op === 'addRecord') {
          superceding._deleted = true;
        }
      } else if (!superceding._deleted && (consecutiveOps || superceding.op === 'replaceAttribute')) {
        if (isReplaceFieldOp(superceded.op) && isReplaceFieldOp(superceding.op)) {
          if (superceded.op === superceding.op && (superceded.op === 'replaceAttribute' && superceded.attribute === superceding.attribute || superceded.relationship === superceding.relationship)) {
            superceded._deleted = true;
          } else {
            superceded.op = 'replaceRecord';
            if (superceded.op === 'replaceAttribute') {
              replaceRecordAttribute(superceded.record, superceded.attribute, superceded.value);
              delete superceded.attribute;
              delete superceded.value;
            } else if (superceded.op === 'replaceHasOne') {
              replaceRecordHasOne(superceded.record, superceded.relationship, superceded.relatedRecord);
              delete superceded.relationship;
              delete superceded.relatedRecord;
            } else if (superceded.op === 'replaceHasMany') {
              replaceRecordHasMany(superceded.record, superceded.relationship, superceded.relatedRecords);
              delete superceded.relationship;
              delete superceded.relaetdRecords;
            }
            if (superceding.op === 'replaceAttribute') {
              replaceRecordAttribute(superceded.record, superceding.attribute, superceding.value);
            } else if (superceding.op === 'replaceHasOne') {
              replaceRecordHasOne(superceded.record, superceding.relationship, superceding.relatedRecord);
            } else if (superceding.op === 'replaceHasMany') {
              replaceRecordHasMany(superceded.record, superceding.relationship, superceding.relatedRecords);
            }
          }
        } else if ((superceded.op === 'addRecord' || superceded.op === 'replaceRecord') && isReplaceFieldOp(superceding.op)) {
          if (superceding.op === 'replaceAttribute') {
            replaceRecordAttribute(superceded.record, superceding.attribute, superceding.value);
          } else if (superceding.op === 'replaceHasOne') {
            replaceRecordHasOne(superceded.record, superceding.relationship, superceding.relatedRecord);
          } else if (superceding.op === 'replaceHasMany') {
            replaceRecordHasMany(superceded.record, superceding.relationship, superceding.relatedRecords);
          }
          superceding._deleted = true;
        } else if (superceding.op === 'addToHasMany') {
          if (superceded.op === 'addRecord') {
            addToHasMany(superceded.record, superceding.relationship, superceding.relatedRecord);
            superceding._deleted = true;
          } else if (superceded.op === 'replaceRecord') {
            if (superceded.record.relationships && superceded.record.relationships[superceding.relationship] && superceded.record.relationships[superceding.relationship].data) {
              addToHasMany(superceded.record, superceding.relationship, superceding.relatedRecord);
              superceding._deleted = true;
            }
          }
        } else if (superceding.op === 'removeFromHasMany') {
          if (superceded.op === 'addToHasMany' && superceded.relationship === superceding.relationship && identifiers.eqIdentity(superceded.relatedRecord, superceding.relatedRecord)) {
            superceded._deleted = true;
            superceding._deleted = true;
          } else if (superceded.op === 'addRecord' || superceded.op === 'replaceRecord') {
            if (superceded.record.relationships && superceded.record.relationships[superceding.relationship] && superceded.record.relationships[superceding.relationship].data && superceded.record.relationships[superceding.relationship].data[identifiers.toIdentifier(superceding.relatedRecord)]) {
              delete superceded.record.relationships[superceding.relationship].data[identifiers.toIdentifier(superceding.relatedRecord)];
              superceding._deleted = true;
            }
          }
        }
      }
    }
  }

  function isReplaceFieldOp(op) {
    return op === 'replaceAttribute' || op === 'replaceHasOne' || op === 'replaceHasMany';
  }

  function replaceRecordAttribute(record, attribute, value) {
    record.attributes = record.attributes || {};
    record.attributes[attribute] = value;
  }

  function replaceRecordHasOne(record, relationship, relatedRecord) {
    record.relationships = record.relationships || {};
    record.relationships[relationship] = record.relationships[relationship] || {};
    record.relationships[relationship].data = relatedRecord ? identifiers.toIdentifier(relatedRecord) : null;
  }

  function replaceRecordHasMany(record, relationship, relatedRecords) {
    record.relationships = record.relationships || {};
    record.relationships[relationship] = record.relationships[relationship] || {};
    record.relationships[relationship].data = {};
    relatedRecords.forEach(function (r) {
      record.relationships[relationship].data[identifiers.toIdentifier(r)] = true;
    });
  }

  function addToHasMany(record, relationship, relatedRecord) {
    record.relationships = record.relationships || {};
    record.relationships[relationship] = record.relationships[relationship] || {};
    record.relationships[relationship].data = record.relationships[relationship].data || {};
    record.relationships[relationship].data[identifiers.toIdentifier(relatedRecord)] = true;
  }

  /**
   Coalesces operations into a minimal set of equivalent operations.
    This method respects the order of the operations array and does not allow
   reordering of operations that affect relationships.
    @method coalesceOperations
   @for Orbit
   @param {Array} operations
   @returns {Array}
   */
  function coalesceOperations(operations) {
    for (var i = 0, l = operations.length; i < l; i++) {
      var currentOp = operations[i];
      var consecutiveOps = true;

      for (var j = i + 1; j < l; j++) {
        var nextOp = operations[j];

        mergeOps(currentOp, nextOp, consecutiveOps);

        if (currentOp._deleted) {
          break;
        } else if (!nextOp._deleted) {
          consecutiveOps = false;
        }
      }
    }

    return operations.filter(function (o) {
      return !o._deleted;
    });
  }

  function recordDiffs(record, updatedRecord) {
    var diffs = [];

    if (record && updatedRecord) {
      (function () {
        var recordIdentity = identifiers.identity(record);

        if (updatedRecord.attributes) {
          Object.keys(updatedRecord.attributes).forEach(function (attribute) {
            var value = updatedRecord.attributes[attribute];
            if (record.attributes === undefined || !eq.eq(record.attributes[attribute], value)) {
              diffs.push({
                op: 'replaceAttribute',
                record: recordIdentity,
                attribute: attribute,
                value: value
              });
            }
          });
        }

        if (updatedRecord.keys) {
          Object.keys(updatedRecord.keys).forEach(function (key) {
            var value = updatedRecord.keys[key];
            if (record.keys === undefined || !eq.eq(record.keys[key], value)) {
              diffs.push({
                op: 'replaceKey',
                record: recordIdentity,
                key: key,
                value: value
              });
            }
          });
        }

        // TODO - handle relationships
      })();
    }

    return diffs;
  }
});
'use strict';

define('orbit/lib/paths', ['exports', 'orbit/lib/objects'], function (exports, objects) {

  'use strict';

  exports.joinPath = joinPath;
  exports.splitPath = splitPath;

  function joinPath(path) {
    if (objects.isArray(path)) {
      if (path.length === 0) {
        return '/';
      } else {
        return '/' + path.join('/');
      }
    } else {
      return path;
    }
  }

  function splitPath(path) {
    if (typeof path === 'string') {
      if (path.indexOf('/') === 0) {
        path = path.substr(1);
      }

      if (path.length === 0) {
        return [];
      } else {
        if (path[path.length - 1] === '/') {
          path = path.substr(0, path.length - 1);
        }
        return path.split('/');
      }
    } else {
      return path;
    }
  }
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/lib/pattern-matcher', ['exports'], function (exports) {

  'use strict';

  exports.buildPatternMatcher = buildPatternMatcher;

  function getPath(object, path) {
    return path.reduce(function (reference, property) {
      return reference && reference[property];
    }, object);
  }

  var ValueMatcher = (function () {
    function ValueMatcher(path, value) {
      _classCallCheck(this, ValueMatcher);

      this.path = path;
      this.value = value;
    }

    _createClass(ValueMatcher, [{
      key: 'matches',
      value: function matches(object) {
        var value = getPath(object, this.path);
        return value === this.value;
      }
    }]);

    return ValueMatcher;
  })();

  var ValuesMatcher = (function () {
    function ValuesMatcher(path, values) {
      _classCallCheck(this, ValuesMatcher);

      this.path = path;
      this.values = values;
    }

    _createClass(ValuesMatcher, [{
      key: 'matches',
      value: function matches(object) {
        var value = getPath(object, this.path);
        return this.values.indexOf(value) !== -1;
      }
    }]);

    return ValuesMatcher;
  })();

  function isString(value) {
    return typeof value === 'string';
  }

  var isArray = Array.isArray;

  var PatternMatcher = (function () {
    function PatternMatcher(pattern) {
      _classCallCheck(this, PatternMatcher);

      this._matchers = [];
      this._buildMatchers(pattern);
    }

    _createClass(PatternMatcher, [{
      key: 'matches',
      value: function matches(object) {
        return this._matchers.every(function (pathMatcher) {
          return pathMatcher.matches(object);
        });
      }
    }, {
      key: '_buildMatchers',
      value: function _buildMatchers(pattern) {
        var _this = this;

        var currentPath = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

        if (isString(pattern) || !pattern) {
          return this._addValueMatcher(currentPath, pattern);
        }
        if (isArray(pattern)) {
          return this._addValuesMatcher(currentPath, pattern);
        }

        Object.keys(pattern).forEach(function (key) {
          var subPattern = pattern[key];
          _this._buildMatchers(subPattern, [].concat(_toConsumableArray(currentPath), [key]));
        });
      }
    }, {
      key: '_addValueMatcher',
      value: function _addValueMatcher(path, value) {
        this._matchers.push(new ValueMatcher(path, value));
      }
    }, {
      key: '_addValuesMatcher',
      value: function _addValuesMatcher(path, values) {
        this._matchers.push(new ValuesMatcher(path, values));
      }
    }]);

    return PatternMatcher;
  })();

  exports['default'] = PatternMatcher;

  function buildPatternMatcher(pattern) {
    var matcher = new PatternMatcher(pattern);
    return matcher.matches.bind(matcher);
  }
});
'use strict';

define('orbit/lib/strings', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   Uppercase the first letter of a string, but don't change the remainder.
    @method capitalize
   @for Orbit
   @param {String} str
   @returns {String} capitalized string
   */
  var capitalize = function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
   Convert underscored, dasherized, or space-delimited words into lowerCamelCase.
    @method camelize
   @for Orbit
   @param {String} str
   @returns {String} camelized string
   */
  var camelize = function camelize(str) {
    return str.replace(/(\-|\_|\.|\s)+(.)?/g, function (match, separator, chr) {
      return chr ? chr.toUpperCase() : '';
    }).replace(/(^|\/)([A-Z])/g, function (match) {
      return match.toLowerCase();
    });
  };

  /**
   Converts a camelized string into all lowercase separated by underscores.
    @method decamelize
   @for Orbit
   @param {String} str
   @returns {String} lower case, underscored string
   */
  var decamelize = function decamelize(str) {
    return str.replace(/([a-z\d])([A-Z])/g, '$1_$2').toLowerCase();
  };

  /**
   Dasherize words that are underscored, space-delimited, or camelCased.
    @method dasherize
   @for Orbit
   @param {String} str
   @returns {String} dasherized string
   */
  var dasherize = function dasherize(str) {
    return decamelize(str).replace(/[ _]/g, '-');
  };

  /**
   Underscore words that are dasherized, space-delimited, or camelCased.
    @method underscore
   @for Orbit
   @param {String} str
   @returns {String} underscored string
   */
  var underscore = function underscore(str) {
    return str.replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/\-|\s+/g, '_').toLowerCase();
  };

  exports.capitalize = capitalize;
  exports.camelize = camelize;
  exports.decamelize = decamelize;
  exports.dasherize = dasherize;
  exports.underscore = underscore;
});
'use strict';

define('orbit/lib/stubs', ['exports'], function (exports) {

	'use strict';

	/* eslint-disable valid-jsdoc */

	/**
  Empty method that does nothing.
 	 Use as a placeholder for non-required static methods.
 	 @method noop
  @for Orbit
  */
	var noop = function noop() {};

	/**
  Empty method that should be overridden. Otherwise, it will throw an Error.
 	 Use as a placeholder for required static methods.
 	 @method required
  @for Orbit
  */
	var required = function required() {
		throw new Error('Missing implementation');
	};

	exports.noop = noop;
	exports.required = required;
});
'use strict';

define('orbit/lib/transforms', ['exports', 'orbit/transform', 'orbit/lib/operations'], function (exports, Transform, ___operations) {

  'use strict';

  exports.operationsInTransforms = operationsInTransforms;
  exports.reduceTransforms = reduceTransforms;
  exports.coalesceTransforms = coalesceTransforms;

  /* eslint-disable valid-jsdoc */
  function operationsInTransforms(transforms) {
    var operations = [];

    transforms.forEach(function (t) {
      Array.prototype.push.apply(operations, t.operations);
    });

    return operations;
  }

  /**
   Reduces an array of transforms into a single transform containing a merged set
   of operations.
    @method reduceTransforms
   @param {Array} transforms
   @returns {Transform} A new Transform that contains a merged set of operations.
   */
  function reduceTransforms(transforms) {
    var operations = operationsInTransforms(transforms);

    return Transform['default'].from(operations);
  }

  /**
   Reduces an array of transforms into a single transform containing a minimal set
   of equivalent coalesced operations.
    @method coalesceTransforms
   @param {Array} transforms
   @returns {Transform} A new Transform that contains a merged and coalesced set of operations.
   */
  function coalesceTransforms(transforms) {
    var operations = operationsInTransforms(transforms);
    var coalescedOperations = ___operations.coalesceOperations(operations);

    return Transform['default'].from(coalescedOperations);
  }
});
'use strict';

define('orbit/lib/uuid', ['exports'], function (exports) {

  'use strict';

  /**
   * Fast UUID generator, RFC4122 version 4 compliant.
   * @author Jeff Ward (jcward.com).
   * @license MIT license
   * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
   **/

  /**
   * ES 6 Module
   * @author Andrew Hacking (ahacking@gmail.com)
   *
   **/
  var lut = [];for (var i = 0; i < 256; i++) {
    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
  }

  /**
   `uuid` generates a Version 4 UUID using Jeff Wards high performance generator.
    @method v4uuid
   @for Orbit
   @returns {String} a version 4 UUID
   */
  var uuid = function uuid() {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  };

  exports.uuid = uuid;
});
'use strict';

define('orbit/main', ['exports'], function (exports) {

  'use strict';

  var Orbit = {};

  if (typeof self.Promise !== 'undefined') {
    Orbit.Promise = self.Promise;
  }

  exports['default'] = Orbit;
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/notifier', ['exports'], function (exports) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  /**
   The `Notifier` class can emit messages to an array of subscribed listeners.
   Here's a simple example:
    ```javascript
   var notifier = new Orbit.Notifier();
   notifier.addListener(function(message) {
     console.log("I heard " + message);
   });
   notifier.addListener(function(message) {
     console.log("I also heard " + message);
   });
    notifier.emit('hello'); // logs "I heard hello" and "I also heard hello"
   ```
    Calls to `emit` will send along all of their arguments.
    @class Notifier
   @namespace Orbit
   @constructor
   */

  var Notifier = (function () {
    function Notifier() {
      _classCallCheck(this, Notifier);

      this.listeners = [];
    }

    /**
     Add a callback as a listener, which will be triggered when sending
     notifications.
      @method addListener
     @param {Function} callback Function to call as a notification
     @param {Object} binding Context in which to call `callback`
     */

    _createClass(Notifier, [{
      key: 'addListener',
      value: function addListener(callback, binding) {
        binding = binding || this;
        this.listeners.push([callback, binding]);
      }

      /**
       Remove a listener so that it will no longer receive notifications.
        @method removeListener
       @param {Function} callback Function registered as a callback
       @param {Object} binding Context in which `callback` was registered
       */
    }, {
      key: 'removeListener',
      value: function removeListener(callback, binding) {
        var listeners = this.listeners;
        var listener = undefined;

        binding = binding || this;
        for (var i = 0, len = listeners.length; i < len; i++) {
          listener = listeners[i];
          if (listener && listener[0] === callback && listener[1] === binding) {
            listeners.splice(i, 1);
            return;
          }
        }
      }

      /**
       Notify registered listeners.
        Any responses from listeners will be ignored.
        @method emit
       @param {*} Any number of parameters to be sent to listeners
       */
    }, {
      key: 'emit',
      value: function emit() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this.listeners.slice(0).forEach(function (listener) {
          listener[0].apply(listener[1], args);
        });
      }
    }]);

    return Notifier;
  })();

  exports['default'] = Notifier;
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/query', ['exports', 'orbit/lib/uuid'], function (exports, uuid) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  var Query = function Query(expression, _options) {
    _classCallCheck(this, Query);

    this.expression = expression;

    var options = _options || {};

    this.id = options.id || uuid.uuid();
  };

  exports['default'] = Query;

  Query.from = function (queryOrExpression) {
    if (queryOrExpression.toQueryExpression) {
      return new Query(queryOrExpression.toQueryExpression());
    } else if (queryOrExpression instanceof Query) {
      return queryOrExpression;
    } else {
      return new Query(queryOrExpression);
    }
  };
});
'use strict';

define('orbit/query/builder', ['exports', 'orbit/query/expression', 'orbit/query/terms'], function (exports, expression, terms) {

  'use strict';

  exports['default'] = {
    records: function records(type) {
      return new terms.Records(expression.queryExpression('records', type));
    },

    record: function record(recordIdentity) {
      return new terms.Record(recordIdentity);
    },

    relatedRecord: function relatedRecord(record, relationship) {
      return new terms.RelatedRecord(record, relationship);
    },

    relatedRecords: function relatedRecords(record, relationship) {
      return new terms.RelatedRecords(record, relationship);
    },

    or: function or(a, b) {
      return expression.queryExpression('or', a, b);
    },

    and: function and(a, b) {
      return expression.queryExpression('and', a, b);
    }
  };
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/query/context', ['exports', 'orbit/query/expression'], function (exports, ___expression) {

  'use strict';

  var QueryContext = (function () {
    function QueryContext(evaluator) {
      _classCallCheck(this, QueryContext);

      this.evaluator = evaluator;
    }

    _createClass(QueryContext, [{
      key: 'evaluate',
      value: function evaluate(expression) {
        if (___expression.isQueryExpression(expression)) {
          var operator = this.evaluator.operators[expression.op];

          if (!operator) {
            throw new Error('Unable to find operator: ' + expression.op);
          }

          return operator.evaluate(this, expression.args);
        } else {
          return expression;
        }
      }
    }]);

    return QueryContext;
  })();

  exports['default'] = QueryContext;
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/query/evaluator', ['exports', 'orbit/query/expression'], function (exports, ___expression) {

  'use strict';

  var QueryEvaluator = (function () {
    function QueryEvaluator(target, operators) {
      _classCallCheck(this, QueryEvaluator);

      this.target = target;
      this.operators = operators;
    }

    _createClass(QueryEvaluator, [{
      key: 'evaluate',
      value: function evaluate(expression, _context) {
        if (___expression.isQueryExpression(expression)) {
          var operator = this.operators[expression.op];
          if (!operator) {
            throw new Error('Unable to find operator: ' + expression.op);
          }
          var context = _context || {};
          return operator.apply(this, [context].concat(expression.args));
        } else {
          return expression;
        }
      }
    }]);

    return QueryEvaluator;
  })();

  exports['default'] = QueryEvaluator;
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/query/expression', ['exports', 'orbit/lib/objects'], function (exports, objects) {

  'use strict';

  exports.queryExpression = queryExpression;
  exports.isQueryExpression = isQueryExpression;

  var QueryExpression = (function () {
    function QueryExpression(op, args) {
      _classCallCheck(this, QueryExpression);

      this.__oqe__ = true;
      this.op = op;
      this.args = args;
    }

    _createClass(QueryExpression, [{
      key: 'toString',
      value: function toString() {
        var formattedArgs = this.args.map(function (arg) {
          return '' + arg;
        }).join(', ');
        return this.op + '(' + formattedArgs + ')';
      }
    }]);

    return QueryExpression;
  })();

  function queryExpression(op) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return new QueryExpression(op, args);
  }

  function isQueryExpression(obj) {
    return objects.isObject(obj) && obj.__oqe__;
  }

  exports['default'] = QueryExpression;
});
'use strict';

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/query/terms', ['exports', 'orbit/query/expression'], function (exports, ___expression) {

  'use strict';

  var TermBase = (function () {
    function TermBase(expression) {
      _classCallCheck(this, TermBase);

      this.expression = expression;
    }

    _createClass(TermBase, [{
      key: 'toQueryExpression',
      value: function toQueryExpression() {
        return this.expression;
      }
    }]);

    return TermBase;
  })();

  var Cursor = (function (_TermBase) {
    _inherits(Cursor, _TermBase);

    function Cursor() {
      _classCallCheck(this, Cursor);

      _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(Cursor, [{
      key: 'get',
      value: function get(path) {
        return new Value(___expression.queryExpression('get', path));
      }
    }]);

    return Cursor;
  })(TermBase);

  var Value = (function (_TermBase2) {
    _inherits(Value, _TermBase2);

    function Value() {
      _classCallCheck(this, Value);

      _get(Object.getPrototypeOf(Value.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(Value, [{
      key: 'equal',
      value: function equal(value) {
        return ___expression.queryExpression('equal', this.expression, value);
      }
    }]);

    return Value;
  })(TermBase);

  var RecordCursor = (function (_Cursor) {
    _inherits(RecordCursor, _Cursor);

    function RecordCursor() {
      _classCallCheck(this, RecordCursor);

      _get(Object.getPrototypeOf(RecordCursor.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(RecordCursor, [{
      key: 'attribute',
      value: function attribute(name) {
        return new Value(___expression.queryExpression('attribute', name));
      }
    }]);

    return RecordCursor;
  })(Cursor);

  var Record = (function (_TermBase3) {
    _inherits(Record, _TermBase3);

    function Record(record) {
      _classCallCheck(this, Record);

      _get(Object.getPrototypeOf(Record.prototype), 'constructor', this).call(this, ___expression.queryExpression('record', record));
    }

    return Record;
  })(TermBase);

  var Records = (function (_TermBase4) {
    _inherits(Records, _TermBase4);

    function Records() {
      _classCallCheck(this, Records);

      _get(Object.getPrototypeOf(Records.prototype), 'constructor', this).apply(this, arguments);
    }

    _createClass(Records, [{
      key: 'filter',
      value: function filter(predicateExpression) {
        var filterBuilder = new RecordCursor();
        return new this.constructor(___expression.queryExpression('filter', this.expression, predicateExpression(filterBuilder)));
      }
    }, {
      key: 'filterAttributes',
      value: function filterAttributes(attributeValues) {
        var attributeExpressions = Object.keys(attributeValues).map(function (attribute) {
          return ___expression.queryExpression('equal', ___expression.queryExpression('attribute', attribute), attributeValues[attribute]);
        });

        var andExpression = attributeExpressions.length === 1 ? attributeExpressions[0] : ___expression.queryExpression.apply(___expression, ['and'].concat(_toConsumableArray(attributeExpressions)));

        return new this.constructor(___expression.queryExpression('filter', this.expression, andExpression));
      }
    }], [{
      key: 'withScopes',
      value: function withScopes(scopes) {
        var typeTerm = function typeTerm(oqe) {
          Records.call(this, oqe);
        };

        typeTerm.prototype = Object.create(Records.prototype);
        Object.assign(typeTerm.prototype, scopes);

        return typeTerm;
      }
    }]);

    return Records;
  })(TermBase);

  var RelatedRecord = (function (_TermBase5) {
    _inherits(RelatedRecord, _TermBase5);

    function RelatedRecord(record, relationship) {
      _classCallCheck(this, RelatedRecord);

      _get(Object.getPrototypeOf(RelatedRecord.prototype), 'constructor', this).call(this, ___expression.queryExpression('relatedRecord', record, relationship));
    }

    return RelatedRecord;
  })(TermBase);

  var RelatedRecords = (function (_TermBase6) {
    _inherits(RelatedRecords, _TermBase6);

    function RelatedRecords(record, relationship) {
      _classCallCheck(this, RelatedRecords);

      _get(Object.getPrototypeOf(RelatedRecords.prototype), 'constructor', this).call(this, ___expression.queryExpression('relatedRecords', record, relationship));
    }

    return RelatedRecords;
  })(TermBase);

  exports.TermBase = TermBase;
  exports.Cursor = Cursor;
  exports.Value = Value;
  exports.RecordCursor = RecordCursor;
  exports.Record = Record;
  exports.Records = Records;
  exports.RelatedRecord = RelatedRecord;
  exports.RelatedRecords = RelatedRecords;
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/schema', ['exports', 'orbit/lib/objects', 'orbit/lib/uuid', 'orbit/lib/exceptions', 'orbit/evented'], function (exports, objects, uuid, exceptions, Evented) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  var Schema = (function () {
    /**
     * Create a new Schema.
     *
     * @constructor
     * @param {Object}   [settings={}]            Optional. Configuration settings.
     * @param {Integer}  [settings.version]       Optional. Schema version. Defaults to 1.
     * @param {Object}   [settings.models]        Optional. Schemas for individual models supported by this schema.
     * @param {Object}   [settings.modelDefaults] Optional. Defaults for model schemas.
     * @param {Function} [settings.pluralize]     Optional. Function used to pluralize names.
     * @param {Function} [settings.singularize]   Optional. Function used to singularize names.
     */

    function Schema() {
      var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _classCallCheck(this, Schema);

      if (settings.version === undefined) {
        settings.version = 1;
      }
      this._applySettings(settings);
    }

    /**
     * Version
     * @return {Integer} Version of schema.
     */

    _createClass(Schema, [{
      key: 'upgrade',

      /**
       * Upgrades Schema to a new version with new settings.
       *
       * Emits the `upgrade` event to cue sources to upgrade their data.
       *
       * @param {Object}   [settings={}]            Settings.
       * @param {Integer}  [settings.version]       Optional. Schema version. Defaults to the current version + 1.
       * @param {Object}   [settings.models]        Schemas for individual models supported by this schema.
       * @param {Object}   [settings.modelDefaults] Optional. Defaults for model schemas.
       * @param {Function} [settings.pluralize]     Optional. Function used to pluralize names.
       * @param {Function} [settings.singularize]   Optional. Function used to singularize names.
       */
      value: function upgrade() {
        var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (settings.version === undefined) {
          settings.version = this._version + 1;
        }
        this._applySettings(settings);
        this.emit('upgrade', this._version);
      }

      /**
       * Registers a complete set of settings
       *
       * @private
       * @param {Object} settings Settings passed into `constructor` or `upgrade`.
       */
    }, {
      key: '_applySettings',
      value: function _applySettings(settings) {
        // Version
        this._version = settings.version;

        // Set inflection functions
        if (settings.pluralize) {
          this.pluralize = settings.pluralize;
        }
        if (settings.singularize) {
          this.singularize = settings.singularize;
        }

        // Set model schema defaults
        if (settings.modelDefaults) {
          this.modelDefaults = settings.modelDefaults;
        } else if (this.modelDefaults === undefined) {
          this.modelDefaults = {
            id: { defaultValue: uuid.uuid }
          };
        }

        // Register model schemas
        if (settings.models) {
          this._registerModels(settings.models);
        }
      }

      /**
       * Registers the schema of all models.
       *
       * @private
       * @param {Object} models Hash of models, keyed by type
       */
    }, {
      key: '_registerModels',
      value: function _registerModels(models) {
        var _this = this;

        this.models = {};
        if (models) {
          Object.keys(models).forEach(function (modelName) {
            _this._registerModel(modelName, models[modelName]);
          });
        }
      }

      /**
       * Registers a model's schema definition.
       *
       * @private
       * @param {String} name       Name of the model
       * @param {Object} definition Model schema definition
       */
    }, {
      key: '_registerModel',
      value: function _registerModel(name, definition) {
        this.models[name] = this._mergeModelSchemas({}, this.modelDefaults, definition);
      }

      /**
       * Normalizes a record according to its type and corresponding schema
       * definition.
       *
       * A record's primary key, relationships, and meta data will all be initialized.
       *
       * A record can only be normalized once. A flag is set on the record
       * (`__normalized`) to prevent "re-normalization".
       *
       * @param {Object} record Record data
       * @return {Object} Normalized version of `data`
       */
    }, {
      key: 'normalize',
      value: function normalize(record) {
        if (record.__normalized) {
          return record;
        }

        record.__normalized = true;

        this.initDefaults(record);

        return record;
      }

      /**
       * Returns a model definition.
       *
       * If no model has been defined, a `ModelNotRegisteredException` is raised.
       *
       * @param {String} type Type of model
       * @return {Object} Model definition
       */
    }, {
      key: 'modelDefinition',
      value: function modelDefinition(type) {
        var definition = this.models[type];

        if (!definition) {
          throw new exceptions.ModelNotRegisteredException(type);
        }

        return definition;
      }
    }, {
      key: 'initDefaults',
      value: function initDefaults(record) {
        if (!record.__normalized) {
          throw new exceptions.OperationNotAllowed('Schema.initDefaults requires a normalized record');
        }

        function defaultValue(record, value) {
          if (typeof value === 'function') {
            return value.call(record);
          } else {
            return value;
          }
        }

        var modelSchema = this.modelDefinition(record.type);

        // init default id value
        if (record.id === undefined) {
          record.id = defaultValue(record, modelSchema.id.defaultValue);
        }

        // init default key values
        if (modelSchema.keys && Object.keys(modelSchema.keys).length > 0) {
          if (record.keys === undefined) {
            record.keys = {};
          }

          for (var key in modelSchema.keys) {
            if (record.keys[key] === undefined) {
              record.keys[key] = defaultValue(record, modelSchema.keys[key].defaultValue);
            }
          }
        }

        // init default attribute values
        if (modelSchema.attributes) {
          if (record.attributes === undefined) {
            record.attributes = {};
          }

          for (var attribute in modelSchema.attributes) {
            if (record.attributes[attribute] === undefined) {
              record.attributes[attribute] = defaultValue(record, modelSchema.attributes[attribute].defaultValue);
            }
          }
        }

        // init default relationship values
        if (modelSchema.relationships) {
          if (record.relationships === undefined) {
            record.relationships = {};
          }

          for (var relationship in modelSchema.relationships) {
            if (record.relationships[relationship] === undefined) {
              var relationshipDefinition = modelSchema.relationships[relationship];
              var defaultForType = relationshipDefinition.type === 'hasMany' ? {} : null;

              record.relationships[relationship] = {
                data: defaultValue(record, relationshipDefinition.defaultValue) || defaultForType
              };
            }
          }
        }
      }

      /**
       * Generate an id for a given model type.
       *
       * @param {String} type A model type
       * @return {String} Generated model ID
       */
    }, {
      key: 'generateDefaultId',
      value: function generateDefaultId(type) {
        var value = this.modelDefinition(type).id.defaultValue;

        if (typeof value === 'function') {
          return value();
        } else {
          return value;
        }
      }

      /**
       A naive pluralization method.
        Override with a more robust general purpose inflector or provide an
       inflector tailored to the vocabularly of your application.
        @param  {String} word
       @return {String} plural form of `word`
       */
    }, {
      key: 'pluralize',
      value: function pluralize(word) {
        return word + 's';
      }

      /**
       A naive singularization method.
        Override with a more robust general purpose inflector or provide an
       inflector tailored to the vocabularly of your application.
        @param  {String} word
       @return {String} singular form of `word`
       */
    }, {
      key: 'singularize',
      value: function singularize(word) {
        if (word.lastIndexOf('s') === word.length - 1) {
          return word.substr(0, word.length - 1);
        } else {
          return word;
        }
      }
    }, {
      key: 'keyDefinition',
      value: function keyDefinition(modelName, key) {
        var modelDef = this.modelDefinition(modelName);

        var keyDef = modelDef.keys[key];
        if (!keyDef) {
          throw new exceptions.KeyNotRegisteredException(modelName, key);
        }

        return keyDef;
      }
    }, {
      key: 'relationshipDefinition',
      value: function relationshipDefinition(modelName, relationship) {
        var modelDef = this.modelDefinition(modelName);

        var relDef = modelDef.relationships[relationship];
        if (!relDef) {
          throw new exceptions.RelationshipNotRegisteredException(modelName, relationship);
        }

        return relDef;
      }
    }, {
      key: '_mergeModelSchemas',
      value: function _mergeModelSchemas(base) {
        var _this2 = this;

        var sources = Array.prototype.slice.call(arguments, 1);

        // ensure model schema has categories set
        base.id = base.id || {};
        base.keys = base.keys || {};
        base.attributes = base.attributes || {};
        base.relationships = base.relationships || {};

        sources.forEach(function (source) {
          source = objects.clone(source);
          _this2._mergeModelFields(base.id, source.id);
          _this2._mergeModelFields(base.keys, source.keys);
          _this2._mergeModelFields(base.attributes, source.attributes);
          _this2._mergeModelFields(base.relationships, source.relationships);
        });

        return base;
      }
    }, {
      key: '_mergeModelFields',
      value: function _mergeModelFields(base, source) {
        if (source) {
          Object.keys(source).forEach(function (field) {
            if (source.hasOwnProperty(field)) {
              var fieldDef = source[field];
              if (fieldDef) {
                base[field] = fieldDef;
              } else {
                // fields defined as falsey should be removed
                delete base[field];
              }
            }
          });
        }
      }
    }, {
      key: 'version',
      get: function get() {
        return this._version;
      }
    }]);

    return Schema;
  })();

  exports['default'] = Schema;

  Evented['default'].extend(Schema.prototype);
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/source', ['exports', 'orbit/main', 'orbit/evented', 'orbit/transform/log', 'orbit/action-queue', 'orbit/lib/assert'], function (exports, Orbit, Evented, TransformLog, ActionQueue, assert) {

  'use strict';

  var Source = (function () {
    function Source() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      _classCallCheck(this, Source);

      assert.assert('Source requires a name', options.name);

      var name = this._name = options.name;
      var bucket = this._bucket = options.bucket;
      this._schema = options.schema;

      this.transformLog = new TransformLog['default'](null, { name: name + '-log', bucket: bucket });
      this.requestQueue = new ActionQueue['default'](this, { name: name + '-requests', bucket: bucket });
      this.syncQueue = new ActionQueue['default'](this, { name: name + '-sync', bucket: bucket });
    }

    _createClass(Source, [{
      key: '_transformed',

      /////////////////////////////////////////////////////////////////////////////
      // Private methods
      /////////////////////////////////////////////////////////////////////////////

      /**
       Notifies listeners that this source has been transformed by emitting the
       `transform` event.
        Resolves when any promises returned to event listeners are resolved.
        Also, adds an entry to the Source's `transformLog` for each transform.
        @private
       @method _transformed
       @param {Array} transforms - Transforms that have occurred.
       @returns {Promise} Promise that resolves to transforms.
      */
      value: function _transformed(transforms) {
        var _this = this;

        return transforms.reduce(function (chain, transform) {
          return chain.then(function () {
            if (_this.transformLog.contains(transform.id)) {
              return Orbit['default'].Promise.resolve();
            }

            return _this.transformLog.append(transform.id).then(function () {
              return _this.settleInSeries('transform', transform);
            });
          });
        }, Orbit['default'].Promise.resolve()).then(function () {
          return transforms;
        });
      }
    }, {
      key: '_enqueueRequest',
      value: function _enqueueRequest(method, data) {
        return enqueueAction(this, this.requestQueue, method, data);
      }
    }, {
      key: '_enqueueSync',
      value: function _enqueueSync(method, data) {
        return enqueueAction(this, this.syncQueue, method, data);
      }
    }, {
      key: 'name',
      get: function get() {
        return this._name;
      }
    }, {
      key: 'bucket',
      get: function get() {
        return this._bucket;
      }
    }, {
      key: 'schema',
      get: function get() {
        return this._schema;
      }
    }]);

    return Source;
  })();

  exports['default'] = Source;

  function enqueueAction(source, queue, method, data) {
    return queue.push('__' + method + '__', {
      data: data,
      meta: {
        method: method
      }
    }).then(function (action) {
      return action.settle();
    });
  }

  Evented['default'].extend(Source.prototype);
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/transform', ['exports', 'orbit/lib/objects', 'orbit/lib/uuid'], function (exports, objects, uuid) {

  'use strict';

  /* eslint-disable valid-jsdoc */

  var Transform = (function () {
    function Transform(ops) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _classCallCheck(this, Transform);

      this.operations = objects.toArray(ops);
      this.id = options.id || uuid.uuid();
    }

    _createClass(Transform, [{
      key: 'isEmpty',
      value: function isEmpty() {
        return this.operations.length === 0;
      }
    }]);

    return Transform;
  })();

  exports['default'] = Transform;

  Transform.from = function (transformOrOperations) {
    if (transformOrOperations instanceof Transform) {
      return transformOrOperations;
    } else {
      return new Transform(transformOrOperations);
    }
  };
});
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

define('orbit/transform/log', ['exports', 'orbit/main', 'orbit/evented', 'orbit/lib/exceptions'], function (exports, Orbit, Evented, exceptions) {

  'use strict';

  /* globals Immutable */

  var TransformLog = (function () {
    function TransformLog(data) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _classCallCheck(this, TransformLog);

      this.name = options.name;
      this.bucket = options.bucket;
      this._reify(data);
    }

    _createClass(TransformLog, [{
      key: 'append',
      value: function append() {
        var _this = this;

        for (var _len = arguments.length, transformIds = Array(_len), _key = 0; _key < _len; _key++) {
          transformIds[_key] = arguments[_key];
        }

        var data = undefined;

        return this.reified.then(function () {
          var _data;

          data = _this._data;
          _this._data = (_data = data).push.apply(_data, transformIds);
          return _this._persist();
        }).then(function () {
          _this.emit('append', transformIds, data);
        });
      }
    }, {
      key: 'before',
      value: function before(transformId) {
        var relativePosition = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var index = this._data.indexOf(transformId);
        if (index === -1) {
          throw new exceptions.TransformNotLoggedException(transformId);
        }

        var position = index + relativePosition;
        if (position < 0 || position >= this._data.size) {
          throw new exceptions.OutOfRangeException(position);
        }

        return this._data.slice(0, position).toJS();
      }
    }, {
      key: 'after',
      value: function after(transformId) {
        var relativePosition = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var index = this._data.indexOf(transformId);
        if (index === -1) {
          throw new exceptions.TransformNotLoggedException(transformId);
        }

        var position = index + 1 + relativePosition;
        if (position < 0 || position > this._data.size) {
          throw new exceptions.OutOfRangeException(position);
        }

        return this._data.slice(position).toJS();
      }
    }, {
      key: 'truncate',
      value: function truncate(transformId) {
        var _this2 = this;

        var relativePosition = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var data = undefined;

        return this.reified.then(function () {
          data = _this2._data;
          var index = _this2._data.indexOf(transformId);
          if (index === -1) {
            throw new exceptions.TransformNotLoggedException(transformId);
          }

          var position = index + relativePosition;
          if (position < 0 || position > _this2._data.size) {
            throw new exceptions.OutOfRangeException(position);
          }

          if (position === _this2._data.length) {
            _this2._data = data.clear();
          } else {
            _this2._data = data.slice(position);
          }

          return _this2._persist();
        }).then(function () {
          _this2.emit('truncate', transformId, relativePosition, data);
        });
      }
    }, {
      key: 'rollback',
      value: function rollback(transformId) {
        var _this3 = this;

        var relativePosition = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var data = undefined;

        return this.reified.then(function () {
          data = _this3._data;
          var index = _this3._data.indexOf(transformId);
          if (index === -1) {
            throw new exceptions.TransformNotLoggedException(transformId);
          }

          var position = index + 1 + relativePosition;
          if (position < 0 || position > _this3._data.size) {
            throw new exceptions.OutOfRangeException(position);
          }

          _this3._data = data.setSize(position);

          return _this3._persist();
        }).then(function () {
          _this3.emit('rollback', transformId, relativePosition, data);
        });
      }
    }, {
      key: 'clear',
      value: function clear() {
        var _this4 = this;

        var data = undefined;

        return this.reified.then(function () {
          data = _this4._data;
          _this4._data = data.clear();
          return _this4._persist();
        }).then(function () {
          return _this4.emit('clear', data);
        });
      }
    }, {
      key: 'contains',
      value: function contains(transformId) {
        return this._data.includes(transformId);
      }
    }, {
      key: '_persist',
      value: function _persist() {
        if (this.bucket) {
          return this.bucket.setItem(this.name, this._data.toJS());
        } else {
          return Orbit['default'].Promise.resolve();
        }
      }
    }, {
      key: '_reify',
      value: function _reify(data) {
        var _this5 = this;

        if (!data && this.bucket) {
          this.reified = this.bucket.getItem(this.name).then(function (bucketData) {
            return _this5._initData(bucketData);
          });
        } else {
          this._initData(data);
          this.reified = Orbit['default'].Promise.resolve();
        }
      }
    }, {
      key: '_initData',
      value: function _initData(data) {
        if (data) {
          if (Immutable.List.isList(data)) {
            this._data = data;
          } else {
            this._data = new Immutable.List(data);
          }
        } else {
          this._data = new Immutable.List();
        }
      }
    }, {
      key: 'data',
      get: function get() {
        return this._data;
      }
    }, {
      key: 'head',
      get: function get() {
        return this._data.last();
      }
    }, {
      key: 'entries',
      get: function get() {
        return this._data.toArray();
      }
    }, {
      key: 'length',
      get: function get() {
        return this._data.size;
      }
    }]);

    return TransformLog;
  })();

  exports['default'] = TransformLog;

  Evented['default'].extend(TransformLog.prototype);
});
'use strict';

define('orbit/transform/operators', ['exports'], function (exports) {

  'use strict';

  exports.addRecord = addRecord;
  exports.replaceRecord = replaceRecord;
  exports.removeRecord = removeRecord;
  exports.replaceKey = replaceKey;
  exports.replaceAttribute = replaceAttribute;
  exports.addToHasMany = addToHasMany;
  exports.removeFromHasMany = removeFromHasMany;
  exports.replaceHasMany = replaceHasMany;
  exports.replaceHasOne = replaceHasOne;

  function addRecord(record) {
    return { op: 'addRecord', record: record };
  }

  function replaceRecord(record) {
    return { op: 'replaceRecord', record: record };
  }

  function removeRecord(record) {
    return { op: 'removeRecord', record: record };
  }

  function replaceKey(record, key, value) {
    return { op: 'replaceKey', record: record, key: key, value: value };
  }

  function replaceAttribute(record, attribute, value) {
    return { op: 'replaceAttribute', record: record, attribute: attribute, value: value };
  }

  function addToHasMany(record, relationship, relatedRecord) {
    return { op: 'addToHasMany', record: record, relationship: relationship, relatedRecord: relatedRecord };
  }

  function removeFromHasMany(record, relationship, relatedRecord) {
    return { op: 'removeFromHasMany', record: record, relationship: relationship, relatedRecord: relatedRecord };
  }

  function replaceHasMany(record, relationship, relatedRecords) {
    return { op: 'replaceHasMany', record: record, relationship: relationship, relatedRecords: relatedRecords };
  }

  function replaceHasOne(record, relationship, relatedRecord) {
    return { op: 'replaceHasOne', record: record, relationship: relationship, relatedRecord: relatedRecord };
  }
});//# sourceMappingURL=orbit-core.map