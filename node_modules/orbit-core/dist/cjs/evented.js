'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

var Orbit = require('./main');
var Notifier = require('./notifier');
var assert = require('./lib/assert');
var objects = require('./lib/objects');

exports['default'] = {
  /**
   Mixes the `Evented` interface into an object
    @method extend
   @param {Object} object Object to extend
   @returns {Object} Extended object
   */
  extend: function extend(object) {
    assert.assert('Evented requires Orbit.Promise be defined', Orbit['default'].Promise);

    if (object._evented === undefined) {
      objects.extend(object, this['interface']);
    }

    return object;
  },

  'interface': {
    _evented: true,

    on: function on(eventName, callback, _binding) {
      var binding = _binding || this;

      notifierForEvent(this, eventName, true).addListener(callback, binding);
    },

    off: function off(eventName, callback, _binding) {
      var binding = _binding || this;
      var notifier = notifierForEvent(this, eventName);

      if (notifier) {
        if (callback) {
          notifier.removeListener(callback, binding);
        } else {
          removeNotifierForEvent(this, eventName);
        }
      }
    },

    one: function one(eventName, callback, _binding) {
      var callOnce = undefined;
      var notifier = undefined;
      var binding = _binding || this;

      notifier = notifierForEvent(this, eventName, true);

      callOnce = function () {
        callback.apply(binding, arguments);
        notifier.removeListener(callOnce, binding);
      };

      notifier.addListener(callOnce, binding);
    },

    emit: function emit(eventName) {
      var notifier = notifierForEvent(this, eventName);

      if (notifier) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        notifier.emit.apply(notifier, args);
      }
    },

    listeners: function listeners(eventName) {
      var notifier = notifierForEvent(this, eventName);

      return notifier ? notifier.listeners : [];
    },

    settleInSeries: function settleInSeries(eventName) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      var listeners = this.listeners(eventName);

      return listeners.reduce(function (chain, _ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var callback = _ref2[0];
        var binding = _ref2[1];

        return chain.then(function () {
          return callback.apply(binding, args);
        })['catch'](function (e) {
          console.error('Orbit ignored error in event listener', eventName);
          console.error(e.stack || e);
        });
      }, Orbit['default'].Promise.resolve());
    },

    fulfillInSeries: function fulfillInSeries(eventName) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var listeners = this.listeners(eventName);

      return new Orbit['default'].Promise(function (resolve, reject) {
        fulfillEach(listeners, args, resolve, reject);
      });
    }
  }
};

function notifierForEvent(object, eventName, createIfUndefined) {
  if (object._eventedNotifiers === undefined) {
    object._eventedNotifiers = {};
  }
  var notifier = object._eventedNotifiers[eventName];
  if (!notifier && createIfUndefined) {
    notifier = object._eventedNotifiers[eventName] = new Notifier['default']();
  }
  return notifier;
}

function removeNotifierForEvent(object, eventName) {
  if (object._eventedNotifiers && object._eventedNotifiers[eventName]) {
    delete object._eventedNotifiers[eventName];
  }
}

function fulfillEach(listeners, args, resolve, reject) {
  if (listeners.length === 0) {
    resolve();
  } else {
    var listener = undefined;
    var _listeners = listeners;

    var _listeners2 = _toArray(_listeners);

    listener = _listeners2[0];
    listeners = _listeners2.slice(1);
    var _listener = listener;

    var _listener2 = _slicedToArray(_listener, 2);

    var callback = _listener2[0];
    var binding = _listener2[1];

    var response = callback.apply(binding, args);

    if (response) {
      return Orbit['default'].Promise.resolve(response).then(function () {
        return fulfillEach(listeners, args, resolve, reject);
      })['catch'](function (error) {
        return reject(error);
      });
    } else {
      fulfillEach(listeners, args, resolve, reject);
    }
  }
}