'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Orbit = require('./main');
var Evented = require('./evented');
var TransformLog = require('./transform/log');
var ActionQueue = require('./action-queue');
var assert = require('./lib/assert');

var Source = (function () {
  function Source() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Source);

    assert.assert('Source requires a name', options.name);

    var name = this._name = options.name;
    var bucket = this._bucket = options.bucket;
    this._schema = options.schema;

    this.transformLog = new TransformLog['default'](null, { name: name + '-log', bucket: bucket });
    this.requestQueue = new ActionQueue['default'](this, { name: name + '-requests', bucket: bucket });
    this.syncQueue = new ActionQueue['default'](this, { name: name + '-sync', bucket: bucket });
  }

  _createClass(Source, [{
    key: '_transformed',

    /////////////////////////////////////////////////////////////////////////////
    // Private methods
    /////////////////////////////////////////////////////////////////////////////

    /**
     Notifies listeners that this source has been transformed by emitting the
     `transform` event.
      Resolves when any promises returned to event listeners are resolved.
      Also, adds an entry to the Source's `transformLog` for each transform.
      @private
     @method _transformed
     @param {Array} transforms - Transforms that have occurred.
     @returns {Promise} Promise that resolves to transforms.
    */
    value: function _transformed(transforms) {
      var _this = this;

      return transforms.reduce(function (chain, transform) {
        return chain.then(function () {
          if (_this.transformLog.contains(transform.id)) {
            return Orbit['default'].Promise.resolve();
          }

          return _this.transformLog.append(transform.id).then(function () {
            return _this.settleInSeries('transform', transform);
          });
        });
      }, Orbit['default'].Promise.resolve()).then(function () {
        return transforms;
      });
    }
  }, {
    key: '_enqueueRequest',
    value: function _enqueueRequest(method, data) {
      return enqueueAction(this, this.requestQueue, method, data);
    }
  }, {
    key: '_enqueueSync',
    value: function _enqueueSync(method, data) {
      return enqueueAction(this, this.syncQueue, method, data);
    }
  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }
  }, {
    key: 'bucket',
    get: function get() {
      return this._bucket;
    }
  }, {
    key: 'schema',
    get: function get() {
      return this._schema;
    }
  }]);

  return Source;
})();

exports['default'] = Source;

function enqueueAction(source, queue, method, data) {
  return queue.push('__' + method + '__', {
    data: data,
    meta: {
      method: method
    }
  }).then(function (action) {
    return action.settle();
  });
}

Evented['default'].extend(Source.prototype);