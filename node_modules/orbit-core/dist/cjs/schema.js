'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var objects = require('./lib/objects');
var uuid = require('./lib/uuid');
var exceptions = require('./lib/exceptions');
var Evented = require('./evented');

/* eslint-disable valid-jsdoc */

var Schema = (function () {
  /**
   * Create a new Schema.
   *
   * @constructor
   * @param {Object}   [settings={}]            Optional. Configuration settings.
   * @param {Integer}  [settings.version]       Optional. Schema version. Defaults to 1.
   * @param {Object}   [settings.models]        Optional. Schemas for individual models supported by this schema.
   * @param {Object}   [settings.modelDefaults] Optional. Defaults for model schemas.
   * @param {Function} [settings.pluralize]     Optional. Function used to pluralize names.
   * @param {Function} [settings.singularize]   Optional. Function used to singularize names.
   */

  function Schema() {
    var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Schema);

    if (settings.version === undefined) {
      settings.version = 1;
    }
    this._applySettings(settings);
  }

  /**
   * Version
   * @return {Integer} Version of schema.
   */

  _createClass(Schema, [{
    key: 'upgrade',

    /**
     * Upgrades Schema to a new version with new settings.
     *
     * Emits the `upgrade` event to cue sources to upgrade their data.
     *
     * @param {Object}   [settings={}]            Settings.
     * @param {Integer}  [settings.version]       Optional. Schema version. Defaults to the current version + 1.
     * @param {Object}   [settings.models]        Schemas for individual models supported by this schema.
     * @param {Object}   [settings.modelDefaults] Optional. Defaults for model schemas.
     * @param {Function} [settings.pluralize]     Optional. Function used to pluralize names.
     * @param {Function} [settings.singularize]   Optional. Function used to singularize names.
     */
    value: function upgrade() {
      var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      if (settings.version === undefined) {
        settings.version = this._version + 1;
      }
      this._applySettings(settings);
      this.emit('upgrade', this._version);
    }

    /**
     * Registers a complete set of settings
     *
     * @private
     * @param {Object} settings Settings passed into `constructor` or `upgrade`.
     */
  }, {
    key: '_applySettings',
    value: function _applySettings(settings) {
      // Version
      this._version = settings.version;

      // Set inflection functions
      if (settings.pluralize) {
        this.pluralize = settings.pluralize;
      }
      if (settings.singularize) {
        this.singularize = settings.singularize;
      }

      // Set model schema defaults
      if (settings.modelDefaults) {
        this.modelDefaults = settings.modelDefaults;
      } else if (this.modelDefaults === undefined) {
        this.modelDefaults = {
          id: { defaultValue: uuid.uuid }
        };
      }

      // Register model schemas
      if (settings.models) {
        this._registerModels(settings.models);
      }
    }

    /**
     * Registers the schema of all models.
     *
     * @private
     * @param {Object} models Hash of models, keyed by type
     */
  }, {
    key: '_registerModels',
    value: function _registerModels(models) {
      var _this = this;

      this.models = {};
      if (models) {
        Object.keys(models).forEach(function (modelName) {
          _this._registerModel(modelName, models[modelName]);
        });
      }
    }

    /**
     * Registers a model's schema definition.
     *
     * @private
     * @param {String} name       Name of the model
     * @param {Object} definition Model schema definition
     */
  }, {
    key: '_registerModel',
    value: function _registerModel(name, definition) {
      this.models[name] = this._mergeModelSchemas({}, this.modelDefaults, definition);
    }

    /**
     * Normalizes a record according to its type and corresponding schema
     * definition.
     *
     * A record's primary key, relationships, and meta data will all be initialized.
     *
     * A record can only be normalized once. A flag is set on the record
     * (`__normalized`) to prevent "re-normalization".
     *
     * @param {Object} record Record data
     * @return {Object} Normalized version of `data`
     */
  }, {
    key: 'normalize',
    value: function normalize(record) {
      if (record.__normalized) {
        return record;
      }

      record.__normalized = true;

      this.initDefaults(record);

      return record;
    }

    /**
     * Returns a model definition.
     *
     * If no model has been defined, a `ModelNotRegisteredException` is raised.
     *
     * @param {String} type Type of model
     * @return {Object} Model definition
     */
  }, {
    key: 'modelDefinition',
    value: function modelDefinition(type) {
      var definition = this.models[type];

      if (!definition) {
        throw new exceptions.ModelNotRegisteredException(type);
      }

      return definition;
    }
  }, {
    key: 'initDefaults',
    value: function initDefaults(record) {
      if (!record.__normalized) {
        throw new exceptions.OperationNotAllowed('Schema.initDefaults requires a normalized record');
      }

      function defaultValue(record, value) {
        if (typeof value === 'function') {
          return value.call(record);
        } else {
          return value;
        }
      }

      var modelSchema = this.modelDefinition(record.type);

      // init default id value
      if (record.id === undefined) {
        record.id = defaultValue(record, modelSchema.id.defaultValue);
      }

      // init default key values
      if (modelSchema.keys && Object.keys(modelSchema.keys).length > 0) {
        if (record.keys === undefined) {
          record.keys = {};
        }

        for (var key in modelSchema.keys) {
          if (record.keys[key] === undefined) {
            record.keys[key] = defaultValue(record, modelSchema.keys[key].defaultValue);
          }
        }
      }

      // init default attribute values
      if (modelSchema.attributes) {
        if (record.attributes === undefined) {
          record.attributes = {};
        }

        for (var attribute in modelSchema.attributes) {
          if (record.attributes[attribute] === undefined) {
            record.attributes[attribute] = defaultValue(record, modelSchema.attributes[attribute].defaultValue);
          }
        }
      }

      // init default relationship values
      if (modelSchema.relationships) {
        if (record.relationships === undefined) {
          record.relationships = {};
        }

        for (var relationship in modelSchema.relationships) {
          if (record.relationships[relationship] === undefined) {
            var relationshipDefinition = modelSchema.relationships[relationship];
            var defaultForType = relationshipDefinition.type === 'hasMany' ? {} : null;

            record.relationships[relationship] = {
              data: defaultValue(record, relationshipDefinition.defaultValue) || defaultForType
            };
          }
        }
      }
    }

    /**
     * Generate an id for a given model type.
     *
     * @param {String} type A model type
     * @return {String} Generated model ID
     */
  }, {
    key: 'generateDefaultId',
    value: function generateDefaultId(type) {
      var value = this.modelDefinition(type).id.defaultValue;

      if (typeof value === 'function') {
        return value();
      } else {
        return value;
      }
    }

    /**
     A naive pluralization method.
      Override with a more robust general purpose inflector or provide an
     inflector tailored to the vocabularly of your application.
      @param  {String} word
     @return {String} plural form of `word`
     */
  }, {
    key: 'pluralize',
    value: function pluralize(word) {
      return word + 's';
    }

    /**
     A naive singularization method.
      Override with a more robust general purpose inflector or provide an
     inflector tailored to the vocabularly of your application.
      @param  {String} word
     @return {String} singular form of `word`
     */
  }, {
    key: 'singularize',
    value: function singularize(word) {
      if (word.lastIndexOf('s') === word.length - 1) {
        return word.substr(0, word.length - 1);
      } else {
        return word;
      }
    }
  }, {
    key: 'keyDefinition',
    value: function keyDefinition(modelName, key) {
      var modelDef = this.modelDefinition(modelName);

      var keyDef = modelDef.keys[key];
      if (!keyDef) {
        throw new exceptions.KeyNotRegisteredException(modelName, key);
      }

      return keyDef;
    }
  }, {
    key: 'relationshipDefinition',
    value: function relationshipDefinition(modelName, relationship) {
      var modelDef = this.modelDefinition(modelName);

      var relDef = modelDef.relationships[relationship];
      if (!relDef) {
        throw new exceptions.RelationshipNotRegisteredException(modelName, relationship);
      }

      return relDef;
    }
  }, {
    key: '_mergeModelSchemas',
    value: function _mergeModelSchemas(base) {
      var _this2 = this;

      var sources = Array.prototype.slice.call(arguments, 1);

      // ensure model schema has categories set
      base.id = base.id || {};
      base.keys = base.keys || {};
      base.attributes = base.attributes || {};
      base.relationships = base.relationships || {};

      sources.forEach(function (source) {
        source = objects.clone(source);
        _this2._mergeModelFields(base.id, source.id);
        _this2._mergeModelFields(base.keys, source.keys);
        _this2._mergeModelFields(base.attributes, source.attributes);
        _this2._mergeModelFields(base.relationships, source.relationships);
      });

      return base;
    }
  }, {
    key: '_mergeModelFields',
    value: function _mergeModelFields(base, source) {
      if (source) {
        Object.keys(source).forEach(function (field) {
          if (source.hasOwnProperty(field)) {
            var fieldDef = source[field];
            if (fieldDef) {
              base[field] = fieldDef;
            } else {
              // fields defined as falsey should be removed
              delete base[field];
            }
          }
        });
      }
    }
  }, {
    key: 'version',
    get: function get() {
      return this._version;
    }
  }]);

  return Schema;
})();

exports['default'] = Schema;

Evented['default'].extend(Schema.prototype);