'use strict';

var Orbit = require('../main');
var assert = require('../lib/assert');
var objects = require('../lib/objects');
var Transform = require('../transform');
var Source = require('../source');

exports['default'] = {
  /**
   Mixes the `Updatable` interface into a source.
    The `Updatable` interface adds a single method to a source: `update`. This
   method accepts a `Transform` instance or an array of operations which it then
   converts to a `Transform` instance. The source applies the update and returns
   a promise that resolves when complete.
    This interface is part of the "request flow" in Orbit. Requests trigger
   events before and after processing of each request. Observers can delay the
   resolution of a request by returning a promise in an event listener.
    The `Updatable` interface introduces the following events:
    * `beforeUpdate` - emitted prior to the processing of `update`, this event
     includes the requested `Transform` as an argument.
    * `update` - emitted after an `update` has successfully been applied, this
     event includes the requested `Transform` as an argument.
    * `updateFail` - emitted when an error has occurred applying an update, this
     event's arguments include both the requested `Transform` and the error.
    An `Updatable` source must implement a private method `_update`, which
   performs the processing required for `update` and returns a promise that
   resolves when complete.
    @method extend
   @param {Object} source - Source to extend
   @returns {Object} Extended source
   */
  extend: function extend(source) {
    if (source._updatable === undefined) {
      assert.assert('Updatable interface can only be applied to a Source', source instanceof Source['default']);
      objects.extend(source, this['interface']);
    }
    return source;
  },

  'interface': {
    _updatable: true,

    update: function update(transformOrOperations) {
      var transform = Transform['default'].from(transformOrOperations);

      if (this.transformLog.contains(transform.id)) {
        return Orbit['default'].Promise.resolve([]);
      }

      return this._enqueueRequest('update', transform);
    },

    __update__: function __update__(transform) {
      var _this = this;

      if (this.transformLog.contains(transform.id)) {
        return Orbit['default'].Promise.resolve([]);
      }

      return this.fulfillInSeries('beforeUpdate', transform).then(function () {
        return _this._update(transform);
      }).then(function () {
        return _this._transformed([transform]);
      }).then(function () {
        return _this.settleInSeries('update', transform);
      })['catch'](function (error) {
        return _this.settleInSeries('updateFail', transform, error).then(function () {
          throw error;
        });
      });
    }
  }
};