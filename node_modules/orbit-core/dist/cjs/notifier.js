'use strict';

/* eslint-disable valid-jsdoc */

/**
 The `Notifier` class can emit messages to an array of subscribed listeners.
 Here's a simple example:

 ```javascript
 var notifier = new Orbit.Notifier();
 notifier.addListener(function(message) {
   console.log("I heard " + message);
 });
 notifier.addListener(function(message) {
   console.log("I also heard " + message);
 });

 notifier.emit('hello'); // logs "I heard hello" and "I also heard hello"
 ```

 Calls to `emit` will send along all of their arguments.

 @class Notifier
 @namespace Orbit
 @constructor
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Notifier = (function () {
  function Notifier() {
    _classCallCheck(this, Notifier);

    this.listeners = [];
  }

  /**
   Add a callback as a listener, which will be triggered when sending
   notifications.
    @method addListener
   @param {Function} callback Function to call as a notification
   @param {Object} binding Context in which to call `callback`
   */

  _createClass(Notifier, [{
    key: 'addListener',
    value: function addListener(callback, binding) {
      binding = binding || this;
      this.listeners.push([callback, binding]);
    }

    /**
     Remove a listener so that it will no longer receive notifications.
      @method removeListener
     @param {Function} callback Function registered as a callback
     @param {Object} binding Context in which `callback` was registered
     */
  }, {
    key: 'removeListener',
    value: function removeListener(callback, binding) {
      var listeners = this.listeners;
      var listener = undefined;

      binding = binding || this;
      for (var i = 0, len = listeners.length; i < len; i++) {
        listener = listeners[i];
        if (listener && listener[0] === callback && listener[1] === binding) {
          listeners.splice(i, 1);
          return;
        }
      }
    }

    /**
     Notify registered listeners.
      Any responses from listeners will be ignored.
      @method emit
     @param {*} Any number of parameters to be sent to listeners
     */
  }, {
    key: 'emit',
    value: function emit() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.listeners.slice(0).forEach(function (listener) {
        listener[0].apply(listener[1], args);
      });
    }
  }]);

  return Notifier;
})();

exports['default'] = Notifier;